# 11장. 원시 값과 객체의 비교

1. 원시 값은 변경 불가능한 값 vs 객체는 변경 가능한 값.
2. 원시 값은 메모리에 실제 값 저장 vs 객체는 참조 값 저장.
3. 원시 값은 pass by value vs 객체는 pass by reference.

## 11.1. 원시 값

앞서 설명한 변경 불가능하다는 뜻은 값에 대한 진술임!
이는 데이터의 신뢰성을 보장함.

변경 불가능하다는 의미는...
변수에 새로운 윈시 값을 재할당하면 새로운 메모리를 확보하고 재할당한 원시 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소가 바뀜.
왜? 원시 값은 변경 불가능(불변성) 하기 때문에!

### 11.1.2. 문자열과 불변성

JS에서 문자열은 원시 타입이며, 불변성을 갖고 있음. 또한 유사 배열 객체임...
그렇기 때문에 인덱스를 사용하여 각 문자에 접근가능하나
이미 생생성된 문자열의 일부 문자를 변경해도 반영되지 않음.

```js
var str = 'string';
str[0] = 'S';

console.log(str); //string
```

### 11.1.3. 값에 의한 전달(pass by value)

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(original)의 원시 값이 복사되어 전달되는 것을 `값에 의한 전달`이라 함.
이때 original과 copy의 값은 다른 메모리에 저장된 별개의 값임!

위 방식과는 다르게 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하는 방식으로 `값에 의한 전달`이 동작할 수도 있음. (feat. 파이썬)

이러나 저러나 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할 수 없음!

## 11.2. 객체

객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음.

cf. JS 객체의 관리 방식
- 프로퍼티 키를 인덱스로 하는 해시 테이블.
- JS 객체는 클래스 없이 객체 생성, 생성 이후 동적으로 프로퍼티와 메서드 추가 가능.
- 그렇기 때문에 편하지만 객체 생성과 프로퍼티 접근에 많은 비용 소모.
- 따라서 V8 엔진에서는 히든클래스(자바와 같이 고정된 객체 레이아웃과 유사하게 동작) 방식 채택

### 11.2.1. 변경 가능한 값

객체는 변경 가능한 값임.
객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근 할 수 있음.
따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음.
메모리를 효율적으로 사용하고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계됨.
그런데 여기에는 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 구조적 단점이 있음.

cf.얕은 복사(shallow)와 깊은 복사(deep)
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체임.
- 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만듦.
- 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고도 부름.

### 11.2.2. 참조에 의한 전달(pass by reference)

원본의 참조 값이 복사본에 복사되어 전달되는 것이 `참조에 의한 전달`임.
이것은 두 개의 식별자가 하나의 객체를 공유한다는 것을 뜻함.

`값에 의한 전달`과 `참조에 의한 전달`은 식별자가 기억하는 메모리에 저장되어 있는 값을 복사해 전달한다는 면은 동일하나
메모리에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이가 있음.
그렇기 때문에 어떻게 보면 JS에는 `값에 의한 전달`만이 존재한다고 볼 수도 있음. 따라서 혼동을 피하기 위해 `공유에 의한 전달`이라고 표현하는 경우도 있음.

# 12장. 함수

## 12.1. 함수란?

함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것!
함수는 매개변수(함수 내부로 입력을 전달 받는 변수), 인수(입력), 반환값(출력)로 이루어져 있음.
함수는 값임.
함수 정의를 통해 생성함.
인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것을 함수의 호출이라 함.

## 12.2. 함수를 사용하는 이유

코드의 재사용 측면에서 유용함.
코드의 중복을 억제하고 재사용성을 높여 유지보수의 편의성을 높임.
실수를 줄여 코드의 신뢰성을 높임.
적절한 함수 이름을 사용하여 코드의 가독성을 향상시킴.

## 12.3. 함수 리터럴

함수는 객체 타입의 값임. 따라서 함수도 함수 리터럴로 생성가능함. 
함수 리터럴은 function 키워드, 함수 이름, 매개변수목록, 몸체로 구성됨.

```js
var f = function add(x, y) {
    return x + y;
};
```

함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자임.
함수는 객체지만 일반 객체와 달리 호출할 수 있다는 점과 함수 객체만의 고유 프로퍼티를 갖는다는 점이 다름.
함수가 객체라는 특징은 JS 고유의 특징임.

## 12.4. 함수 정의

함수 정의 방법은 4가지가 있음.
1. 함수 선언문.
```js
function add(x, y) {
    return x + y;
}
```
2. 함수 표현식.
```js
var add = function (x, y) {
     return x + y;
}
```
3. Function 생성자 함수.
```js
var add = new Function('x', 'y', 'return x + y');
```
4. 화살표 함수.
```js
var add = (x, y) => x + y;
```

각각의 함수 정의 방법은 서로 미묘하게 동작 방식이 다름.

### 12.4.1. 함수 선언문

```js
function add(x, y) {
    return x + y;
}
```

함수 선언문은 함수 이름을 생략할 수 없음.
함수 선언문은 표현식이 아닌 문임. 따하서 변수에 할당할 수 없음.
근데...

```js
var f = function add(x, y) {
    return x + y;
};
```

위 예시를 보면 할당할 수 있는 것처럼 보이나 이것은 동일한 코드도 문맥에 따라 JS가 다르게 해석해서 그런 것임.
함수 이름이 있는 함수 리터럴을 단독 사용하면 함수 선언문으로 해석하고 동일한 함수 리터럴이 값으로 해석되어야하는 문맥에서는 함수 리털러 표현식으로 해석되는 것임.

그럼 함수 선언문과 함수 표현식은 어떤 점이 다를까?
함수 호출에서 차이가 있음.

함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 이기 때문에 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없음.
그럼 함수 선언문에서는 어떻게 함수 이름으로 함수를 호출할 수 있을까?
고것은 JS 엔진이 암묵적으로 생성한 함수 이름과 동일한 식별자를 생성한 후 함수 객체를 할당해 주기 때문임.

### 12.4.2. 함수 표현식

값의 성질을 갖는 객체를 일급 객체라고 하며 함수는 일급 객체임.
함수 표현식은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식임.
함수 표현식의 함수 이름은 생략하는 것이 일반적임.
함수 선언문이 표현식이 아닌 문인 것에 반해 함수 표현식은 표현식인 문임.

### 12.4.3. 함수 생성 시점과 함수 호이스팅

함수 선언문 정의 함수는 함수 선언문 이전에 함수 호출이 식은 가능하나 표현그렇지 못함.
함수 선언문 정의 함수와 표현식 정의 함수의 함수 생성 시점이 다르기 때문임.

앞서 살펴본 챕터에서 확인했듯 모든 선언문은 런타임 이전 코드 평가 단계에서 먼저 실행됨.
함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유 특징을 함수 호이스팅이라 함.

var 키워드로 선언된 변수는 undefined로 초기화되는데에 반해 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화됨.
함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하지 않고 변수 호이스팅이 발생함.
함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하기 때문에 함수 선언문 보다 함수 표현식을 사용할 것이 권장됨.

### 12.4.4. Function 생성자 함수

```js
var add = new Function('x', 'y', 'return x + y');
```

사실 new 연산자 없이도 사용해도 결과는 동일함.

Function 생성자 함수는 함수 선언문과 함수 표현식으로 생성한 함수와 다르게 클로저(closure)를 생성하지 않음.

### 12.4.5. 화살표 함수

```js
var add = (x, y) => x + y;
```

화살표 함수는 function 키워드 대신 화살표를 사용해 좀 더 간략한 함수 선언이 가능함.
항상 익명 함수로 정의됨.
내부 동작 또한 간략화됨.
생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 argument(인수) 객체를 생성하지 않음.

## 12.5. 함수 호출

### 12.5.1. 매개변수와 인수

함수는 매개변수(parameter)의 개수와 인수(argument)의 개수가 일치하는지 체크하지 않음.
인수가 부족하여 할당되지 않은 매개변수의 값은 undefined임.
인수가 매개변수보다 더 많은 경우 초과된 인수는 무시됨.

여기서 무시된 초과 인수는 그냥 버려지는 것이 아니라 모든 인수가 그렇듯 암묵적으로 arguments 객체의 프로퍼티로 보관됨.

### 12.5.2. 인수 확인

JS 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않음.
JS는 동적 타입 언어임.
따라서 JS에서 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있음.

arguments 객체를 통해 인수 개수를 확인하거나 단축평가 또는 ES6에 도입된 매개변수 기본값을 사용하여 확인할 수 있음.

### 12.5.3. 매개변수의 최대 개수

매개변수의 최대 개수에 대해 명시적으로 제한하고 있지는 않음.
그러나 전달해야 할 인수의 순서를 고려해야 하고 매개변수의 개수나 순서가 변경되면 함수 호출 방법도 바뀌는 등 유지보수성이 나빠질 수 있기 때문에 매개변수의 개수는 적을수록 좋음.
이상적인 함수는 한 가지 일만 해야하며 가급적 작게 만들어야 함.
따라서 매개변수의 개수는 최대 3개 이상을 넘지 않을 것을 권장함.
그 이상의 매개변수가 필요시 객체를 인수로 전달하는 것이 유리함.
이때 주의할 점은 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수효과임.

### 12.5.4. 반환문

반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나갈 수 있게 해주며 return 키워드 뒤에 오는 표현식을 평가해 반환함.
반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환됨.
반환문은 생략가능하며 이때 암묵적으로 undefined를 반환함.
반환문은 함수 몸체 내부에서만 사용 가능함.

cf. Node.js에서는 파일별로 독립적인 파일 스코프를 갖기 때문에 파일의 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않음.

## 12.6. 참조에 의한 전달과 외부 상태의 변경

원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경해도 원본은 훼손되지 않음.
객체 타입 인수는 참조 값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조 값을 통해 객체를 변경할 경우 원본이 훼손됨.
이 경우 상태변화를 추적하기 어려워지고 코드의 복잡성이 증가되며 가독성을 해침.
해결방법은 객체를 불변 객체로 만들어 사용하는 것임.

외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 `순수 함수`라고 함.
순수함수를 통해 부수효과를 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 `함수형 프로그래밍`이라 함.

## 12.7. 다양한 함수의 형태

### 12.7.1. 즉시 실행 함수

함수 정의와 동시에 즉시 호출되는 함수를 `즉시 실행 함수`라고 함.
이 함수는 단 한 번만 호출되며 다시 호출할 수 없음.

```js
(function (){
    var a = 3;
    var b = 5;
    return a * b;
}());
```

먼저 함수 리터럴을 평가해서 함수 객체를 생성할 수 있다면 그룹연선자 이외의 연산자를 사용해도 좋음.
즉시 실행 함수 내에 코드를 모아 두면 혹시 있을 수도 있는 변수나 함수 이름의 충돌을 방지할 수 있음.

### 12.7.2. 재귀 함수

`재귀함수`는 자기 자신을 호출하는 행위, 즉 재귀 호출하는 함수를 말함.
재귀함수 내에는 재귀호출을 멈출 수 있는 탈출조건을 반드시 말들어야 함. 안그러면 스택 오버플로 에러 발생!
재귀함수는 반복문을 사용하는 것보다 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직함.

### 12.7.3. 중첩 함수

함수 내부에 정의된 함수를 `중첩 함수`또는 내부 함수라고 함.
중첩 함수를 포함하는 함수는 `외부 함수`라고 함.
중첩 함수는 외부 함수를 돕는 헬퍼 함수 역할을 함.

### 12.7.4. 콜백 함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 `콜백 함수`라고 하며, 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 `고차 함수`라고 함.
콜백 함수도 고차 함수의 헬퍼 함수 역할을 함.
고차 함수는 콜백 함수를 자신의 일부분으로 합성함.
콜백 함수가 고차 함수 내부에서만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의 하면서 곧바로 고차 함수에 전달하는 것이 일반적임.

```js
repeat(5, function(i){
    if (i%2) console.log(i);
});
```

이때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성함.
따라서 다른 곳에서도 호출할 필요가 있고 콜백함수를 전달 받는 고차 함수가 자주 호출된다면 외부에서 콜백 함수를 정의하는게 유리함.
콜백함수는 비동기 처리, 배열 고차 함수(map, filter, reduce)에 활용되는 중요한 패턴임.

### 12.7.5. 순수 함수와 비순수 함수

어떤 외부 상태에 의존하지도 않고 변경하지도 않는 부수효과가 없는 함수를 `순수 함수`,
부수 효가가 있는 함수를 `비순수 함수`라고 함.

순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환함.
외부 상태에는 전역 변수, 서버 데이터, 파일, Console, DOM 등이 있음.
내부 상태에만 의존한다 해도 그 내부 상태가 호출될 때마다 변화하는 값(현재시간 등)이라면 순수 함수가 아님.

함수가 외부상태를 변경하면 상태 변화를 추적하기 어려워지기 때문에 순수 함수를 사용하는 것이 좋음.
함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임임.
함수형 프로그래밍은 조건문과 반복문을 제거해서 복잡성을 해결하며 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 함.

# 13. 스코프

## 13.1. 스코프란?

변수(모든 식별자)는 자신이 선언된 위치에 의해 자신이 유효한 범위, 즉 다른 코드가 변수 자신을 참조할 수 있는 범위가 결정됨.
스코프를 통해 어떤 변수를 참조해야할 것인지 결정하는 것을 `식별자 결정`이라 함.
이는 식별자를 검색할 때 사용하는 규칙임.

cf. 코드가 어디서 실행되며 주변에 어떤 코드가 있는지를 `렉시컬 환경`이라 하며 이를 구현한 것이 `실행 컨텍스트`임.

식별자는 유일해야 함. 프로그래밍 언어에서는 스코프를 통해 식별자인 변수 이름의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 함.
이런 의미에서 스코프는 네임 스페이스임.

## 13.2. 스코프의 종류

### 13.2.1. 전역과 전역 스코프

전역 변수는 어디서든지 참조할 수 있음.

### 13.2.2. 지역과 지역 스코프

지역이란 함수 몸체 내부를 말함.
지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효함.
JS 엔진은 스코프체인을 통해 참조할 변수를 검색함.

## 13.3. 스코프 체인

스코프는 함수의 중첩에 의해 계층적 구조를 갖음.
외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라 함.
스코프가 계층적으로 연결된 것을 스코프 체인이라 함.
변수를 참조할 때 JS 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색함.
스코프 체인은 물리적인 실체로 존재함.
JS 엔진은 코드를 실행하기 위해 렉시컬 환경을 실제로 생성함.

### 13.3.1. 스코프 체인에 의한 변수 검색

스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하며 선언된 변수를 검색함.
그렇기 때문에 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조 할 수 없음.

### 13.3.2. 스코프 체인에 의한 함수 검색

앞거 살펴본 변수 검색과 동일하게 작동함.
그래서 변수를 검색할 때 사용하는 규칙이라기 보단 식별자를 검색하는 규칙이라는 표현이 적합함.

## 13.4. 함수 레벨 스코프

코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 뜻임.
모든 코드 블록이 지역 스코프를 만드는 것을 블록 레벨 스코프라 함.
하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정함.

ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원함.

## 13.5. 렉시컬 스코프

함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정하는 것을 동적 스코프라함.
함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정하는 것을 렉시컬 스코프(정적 스코프)라고 함.
JS를 비롯한 대부분의 프로그래밍 언어는 렉세컬 스코프를 따름.
즉, 함수의 상위 스코프는 언제나 자신이 정의된 스코프임.
함수정의가 실행되어 생성된 함수 객체는 자신이 정의된 스코프를 기억하여 호출될 때마다 함수의 상위 스코프를 참조함.

# 14. 전역 변수의 문제점

## 14.1. 변수의 생명 주기

### 14.1.1. 지역 변수의 생명 주기

변수는 자신이 선언된 위치에서 생성되고 소멸됨.
전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같음.
지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸함.

지역 변수가 함수보다 오래 생존하는 경우도 있음.
변수의 생명 주기는 메모리 공간이 확보된 시점부터 메모리 공간이 해제되어 가용 메모리 풀에 반환되는 시점까지임.

변수는 자신이 등록된 스코프가 소멸될 때까지 유효함.
누군가가 메모리 공간을 참조하고 있으면 해제되지 않고 확보된 생태로 남아있게 됨.
호이스팅은 스코프를 단위로 동작함.
즉, 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징임.

### 14.1.2. 전역 변수의 생명 주기

var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 됨.
전역 객체는 코드가 실행되기 이전 단계에 JS 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체임.
클라이언트 사이드 환경은 window, 서버 사이드 환경은 global 객체를 의미함.
ES11에서 globalThis로 통일됨.

var 키워드로 선언한 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치함.

## 14.2. 전역 변수의 문제점

- 암묵적 결합

모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합을 허용함.
변수의 유효범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아짐.

- 긴 생명 주기

전역 변수는 생명 주기가 김.
전역 변수보다 상태 변경에 의한 오류가 발생할 확률이 작다는 것을 의미함.
메모리 리소스 또한 짧은 기간만 소비함.

- 스코프 체인 상에서 종점에 존재

전역 변수의 검색 속도가 가장 느림.

- 네임스페이스 오염

파일이 분리되어 있다 해도 하나의 전역 스코프를 공유함.
다른 파일 내에서 동일한 이름으로 명명된 전역 변수나 전역 함수가 같은 스코프 내에 존내할 경우 예상치 못한 결과를 가져올 수 있음.

## 14.3. 전역 변수의 사용을 억제하는 방법

### 14.3.1. 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 됨.

### 14.3.2. 네임스페이스 객체

전역에 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼치로 추가하는 방법임.
식별자 충돌을 방지하는 효과는 있으나 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하진 않음.

### 14.3.3. 모듈 패턴

모듈 패턴은 클래스를 모방해서 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만듦.
전역 변수 억제는 물론 캡슐화까지 구현 가능함.
클로저라는 기능을 통해 전역 변수를 억제할 수 있음.
전역 네임스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 정보 은닉을 구현하기 위해 사용함.

### 14.3.4. ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공함.

# 15. let, const 키워드와 블록 레벨 스코프

## 15.1. var 키워드로 선언한 변수의 문제점

### 15.1.1. 변수 중복 선언 허용

var 키워드로 선언한 변수는 중복 선언이 가능함.
초기화문이 있는 변수 선언문은 JS 엔진에 의해 var 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됨.
의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생함.

### 15.1.2. 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정함.
함수 레벨 스코프는 전역 변수를 남발할 가능성을 높임.
의도치 않게 전역 변수가 중복 선언되는 경우가 발생함.

### 15.1.3. 변수 호이스팅

변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름상 맞지 않을뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남김.

## 15.2. let 키워드

var 키워드의 단점을 보완하기 위해 ES6에서 let과 const를 도입함.

### 15.2.1. 변수 중복 선언 금지

let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생함.

### 15.2.2. 블록 레벨 스코프

let 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름.

### 15.2.3. 변수 호이스팅

let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작함.
let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러가 발생함.
let 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행됨.
선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행됨.
스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대라고 함.

let 변수도 호이스팅이 발생하긴 함. 하지만 초기화 되어 있진 않기 때문에 참조 에러가 발생함.
ES6에서 도입된 let, const를 포함한 모든 선언을 호이스팅함.
단, ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작함.

### 15.2.4. 전역 객체와 let

let 전역 변수는 전역 객체의 프로퍼티가 아님. 보이지 않는 개념적인 블록내에 존재하게 됨.

## 15.3. const 키워드

const 키워드는 상수를 선언하기 위해 사용함. 하지만 반드시 상수만을 위해 사용하지는 않음.

### 15.3.1. 선언과 초기화

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 함.
블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않는 것처럼 동작함.

### 15.3.2. 재할당 금지

const 키워드로 선언한 변수는 재할당이 금지됨.

### 15.3.3. 상수

원시 값은 재할당 없이 값을 변경할 수 있는 방법이 없기 때문에 원시 값을 할당한 경우 변수 값을 변경할 수 없음.
상수는 재할당이 금지된 변수를 말함. 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 함.
일반적으로 상수의 이름은 대문자로 선언하며 스네이크 케이스로 표현함.

### 15.3.4. const 키워드와 객체

const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있음.
변경 가능한 값인 객체는 재할당 없이도 직접 변경이 가능하기 때문임.

const 키워드는 재할당을 금지할 뿐 "불변"을 의미하지는 않음.
프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능함.

## 15.4. var vs. let vs. const

의도치 않은 재할당을 방지하기 때문에 변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋음.
변수를 선언할 때는 일단 const 키워드를 사용하고 반드시 재할당이 필요하다면 그때 const 키워드를 let 키워드로 변경해도 결코 늦지 않음.
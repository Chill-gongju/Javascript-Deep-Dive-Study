# 11장. 원시 값과 객체의 비교
---

1. 원시 값은 변경 불가능한 값 vs 객체는 변경 가능한 값.
2. 원시 값은 메모리에 실제 값 저장 vs 객체는 참조 값 저장.
3. 원시 값은 pass by value vs 객체는 pass by reference.

## 11.1. 원시 값

앞서 설명한 변경 불가능하다는 뜻은 값에 대한 진술임!
이는 데이터의 신뢰성을 보장함.

변경 불가능하다는 의미는...
변수에 새로운 윈시 값을 재할당하면 새로운 메모리를 확보하고 재할당한 원시 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소가 바뀜.
왜? 원시 값은 변경 불가능(불변성) 하기 때문에!

### 11.1.2. 문자열과 불변성

JS에서 문자열은 원시 타입이며, 불변성을 갖고 있음. 또한 유사 배열 객체임...
그렇기 때문에 인덱스를 사용하여 각 문자에 접근가능하나
이미 생생성된 문자열의 일부 문자를 변경해도 반영되지 않음.

```js
var str = 'string';
str[0] = 'S';

console.log(str); //string
```

### 11.1.3. 값에 의한 전달(pass by value)

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(original)의 원시 값이 복사되어 전달되는 것을 `값에 의한 전달`이라 함.
이때 original과 copy의 값은 다른 메모리에 저장된 별개의 값임!

위 방식과는 다르게 변수에 원시 값을 갖는 변수를 할당하는 시점에는 두 변수가 같은 원시 값을 참조하다가 어느 한쪽의 변수에 재할당이 이뤄졌을 때 비로소 새로운 메모리 공간에 재할당된 값을 저장하는 방식으로 `값에 의한 전달`이 동작할 수도 있음. (feat. 파이썬)

이러나 저러나 결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경해도 서로 간섭할 수 없음!

## 11.2. 객체

객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없음.

cf. JS 객체의 관리 방식
- 프로퍼티 키를 인덱스로 하는 해시 테이블.
- JS 객체는 클래스 없이 객체 생성, 생성 이후 동적으로 프로퍼티와 메서드 추가 가능.
- 그렇기 때문에 편하지만 객체 생성과 프로퍼티 접근에 많은 비용 소모.
- 따라서 V8 엔진에서는 히든클래스(자바와 같이 고정된 객체 레이아웃과 유사하게 동작) 방식 채택

### 11.2.1. 변경 가능한 값

객체는 변경 가능한 값임.
객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 참조 값에 접근 할 수 있음.
따라서 객체를 할당한 변수는 재할당 없이 객체를 직접 변경할 수 있음.
메모리를 효율적으로 사용하고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계됨.
그런데 여기에는 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 구조적 단점이 있음.

cf.얕은 복사(shallow)와 깊은 복사(deep)
- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체임.
- 얕은 복사는 객체에 중첩되어 있는 객체의 경우 참조 값을 복사하고
- 깊은 복사는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만듦.
- 원시 값을 할당한 변수를 다른 변수에 할당하는 것을 깊은 복사, 객체를 할당한 변수를 다른 변수에 할당하는 것을 얕은 복사라고도 부름.

### 11.2.2. 참조에 의한 전달(pass by reference)

원본의 참조 값이 복사본에 복사되어 전달되는 것이 `참조에 의한 전달`임.
이것은 두 개의 식별자가 하나의 객체를 공유한다는 것을 뜻함.

`값에 의한 전달`과 `참조에 의한 전달`은 식별자가 기억하는 메모리에 저장되어 있는 값을 복사해 전달한다는 면은 동일하나
메모리에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이가 있음.
그렇기 때문에 어떻게 보면 JS에는 `값에 의한 전달`만이 존재한다고 볼 수도 있음. 따라서 혼동을 피하기 위해 `공유에 의한 전달`이라고 표현하는 경우도 있음.

# 12장. 함수
---

## 12.1. 함수란?

함수는 일련의 과정을 문으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것!
함수는 매개변수(함수 내부로 입력을 전달 받는 변수), 인수(입력), 반환값(출력)로 이루어져 있음.
함수는 값임.
함수 정의를 통해 생성함.
인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것을 함수의 호출이라 함.

## 12.2. 함수를 사용하는 이유

코드의 재사용 측면에서 유용함.
코드의 중복을 억제하고 재사용성을 높여 유지보수의 편의성을 높임.
실수를 줄여 코드의 신뢰성을 높임.
적절한 함수 이름을 사용하여 코드의 가독성을 향상시킴.

## 12.3. 함수 리터럴

함수는 객체 타입의 값임. 따라서 함수도 함수 리터럴로 생성가능함. 
함수 리터럴은 function 키워드, 함수 이름, 매개변수목록, 몸체로 구성됨.

```js
var f = function add(x, y) {
    return x + y;
};
```

함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자임.
함수는 객체지만 일반 객체와 달리 호출할 수 있다는 점과 함수 객체만의 고유 프로퍼티를 갖는다는 점이 다름.
함수가 객체라는 특징은 JS 고유의 특징임.

## 12.4. 함수 정의

함수 정의 방법은 4가지가 있음.
1. 함수 선언문.
```js
function add(x, y) {
    return x + y;
}
```
2. 함수 표현식.
```js
var add = function (x, y) {
     return x + y;
}
```
3. Function 생성자 함수.
```js
var add = new Function('x', 'y', 'return x + y');
```
4. 화살표 함수.
```js
var add = (x, y) => x + y;
```

각각의 함수 정의 방법은 서로 미묘하게 동작 방식이 다름.

### 12.4.1. 함수 선언문

```js
function add(x, y) {
    return x + y;
}
```

함수 선언문은 함수 이름을 생략할 수 없음.
함수 선언문은 표현식이 아닌 문임. 따하서 변수에 할당할 수 없음.
근데...

```js
var f = function add(x, y) {
    return x + y;
};
```

위 예시를 보면 할당할 수 있는 것처럼 보이나 이것은 동일한 코드도 문맥에 따라 JS가 다르게 해석해서 그런 것임.
함수 이름이 있는 함수 리터럴을 단독 사용하면 함수 선언문으로 해석하고 동일한 함수 리터럴이 값으로 해석되어야하는 문맥에서는 함수 리털러 표현식으로 해석되는 것임.

그럼 함수 선언문과 함수 표현식은 어떤 점이 다를까?
함수 호출에서 차이가 있음.

함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자 이기 때문에 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없음.
그럼 함수 선언문에서는 어떻게 함수 이름으로 함수를 호출할 수 있을까?
고것은 JS 엔진이 암묵적으로 생성한 함수 이름과 동일한 식별자를 생성한 후 함수 객체를 할당해 주기 때문임.

### 12.4.2. 함수 표현식

값의 성질을 갖는 객체를 일급 객체라고 하며 함수는 일급 객체임.
함수 표현식은 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 정의 방식임.
함수 표현식의 함수 이름은 생략하는 것이 일반적임.
함수 선언문이 표현식이 아닌 문인 것에 반해 함수 표현식은 표현식인 문임.

### 12.4.3. 함수 생성 시점과 함수 호이스팅

함수 선언문 정의 함수는 함수 선언문 이전에 함수 호출이 가능하나 표현식은 그렇지 못함.
함수 선언문 정의 함수와 표현식 정의 함수의 함수 생성 시점이 다르기 때문임.

앞서 살펴본 챕터에서 확인했듯 모든 선언문은 런타임 이전 코드 평가 단계에서 먼저 실행됨.
함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유 특징을 함수 호이스팅이라 함.

var 키워드로 선언된 변수는 undefined로 초기화되는데에 반해 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화됨.
함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하지 않고 변수 호이스팅이 발생함.
함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시하기 때문에 함수 선언문 보다 함수 표현식을 사용할 것이 권장됨.

### 12.4.4. Function 생성자 함수

```js
var add = new Function('x', 'y', 'return x + y');
```

사실 new 연산자 없이도 사용해도 결과는 동일함.

Function 생성자 함수는 함수 선언문과 함수 표현식으로 생성한 함수와 다르게 클로저(closure)를 생성하지 않음.

### 12.4.5. 화살표 함수

```js
var add = (x, y) => x + y;
```

화살표 함수는 function 키워드 대신 화살표를 사용해 좀 더 간략한 함수 선언이 가능함.
항상 익명 함수로 정의됨.
내부 동작 또한 간략화됨.
생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 argument(인수) 객체를 생성하지 않음.

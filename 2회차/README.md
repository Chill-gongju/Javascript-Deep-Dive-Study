# 11장 ~ 15장

## 호이스팅이 발생하는 이유

자바스크립트 엔진의 동작 방식 때문? 더 자세하게 말하자면, **실행 컨텍스트와 변수 선언 방식**이 주요 원인이다.

1. 자바스크립트 엔진은 코드를 두 단계를 거쳐 실행하는데, 
    1. 코드 실행 전에, 실행 컨텍스트를 생성하면서 변수와 함수 선언을 먼저 등록한다
    2. 그 이후, 실제 코드가 순차적으로 실행되며 값이 할당된다
    
    이 과정에서 변수 선언이 먼저 메모리에 등록되기 때문에, 실행 전에 접근할 수 있는 것처럼 보임 (호이스팅)
    
2. 그럼 왜 선언이 먼저 실행될까?
    
    자바스크립트는 JIT (Just-In-Time) 컴파일 방식을 사용한다.  
    → 코드를 실행하기 전에 먼저 스캔해서 선언을 메모리에 등록하는 과정이 있음
    
    ```jsx
    console.log(foo); // undefined
    var foo = "hello"; // 1. var foo;가 먼저 실행 컨텍스트에 등록됨 2.이후에 hello가 할당됨
    console.log(foo); // 
    ```
    
3. let, const는 var 키워드와 왜 다르게 동작할까?
    
    var는 호이스팅될때 undefined로 초기화됨
    
    let, const는 초기화되지 않고 TDZ(Temporal Dead Zone)에 놓이게 됨 
    
    따라서, let const는 선언 이전에 접근하면 오류가 발생한다.
    
4. 호이스팅은 함수에서도 발생함 → 함수 선언문 vs 함수 표현식
    
    함수 선언문은 전체가 호이스팅된다. 함수 자체가 메모리에 저장되기 때문.
    
    함수 표현식은 변수에 할당하므로, 변수 호이스팅과 같은 방식으로 동작한다.
    

**그럼, 자바스크립트 엔진은 왜 이렇게 동작하도록 설계 되어있을까?**

- 가독성과 유지보수성 향상  → 호이스팅이 없으면 변수가 어디서 선언되었는지 찾기 어렵다?
- 인터프리터 언어지만, 성능 최적화를 위해 컴파일에서 변수 선언을 미리 처리하도록 설계됨
- 유연한 코딩 스타일 지원 → but, 이런 문제로 let const가 도입됨

---

# ⭐️ QUIZ

### 11장 원시 값과 객체의 비교

- 왜 객체는 변경 가능한 값으로 설계되었을까요?
    - 히범: 객체는 크기가 커서 재할당할때 메모리를 크게 잡아먹어서 효율적이지 못함 → 성능을 향상시키기 위해
- 원시 값과 객체는 변수에 저장될 때 어떻게 다르게 저장되나요?
    - 종훈: 음 음 어떻게 다르나요?
    - 히범: 원시값은 값 → 다른 메모리 공간에 재할당, 객체는 참조
- 원시 값이 불변하다는 것은 무엇을 의미하나요?
- 문자열도 원시 값인가요? 그럼, 문자열을 수정할 수 없는 이유는?
    - 문자열은 원시 타입이면서 유사 배열 객체임.
- 깊은 복사(Deep Copy)와 얕은 복사(Shallow Copy)의 차이를 성능적인 측면에서 설명할 수 있나요?
- `==`(동등)과 `===`(일치)의 차이를 원시 타입과 객체 타입 관점에서 설명할 수 있나요?

```tsx
var person1 = {
	name: "Lee"
}

var person2 = {
	name: "Lee"
}

person1 === person2; // false.

var name = "Kim";
var name1 = "kim";

name === name1; // true.
```

- 원시 값을 갖는 변수는 값을 변경할 수 있는 방법이 없나요?
    - 유일한 방법! → 재할당 뿐! ㅎㅎ

### 12장 함수

- 함수 선언문과 함수 표현식의 실행 컨텍스트 차이를 설명하세요.
    - 소연: 함수 표현식은 변수 호이스팅이 발생하기 때문에 선언 이전에 호출이 불가능하다
        
        undefined으로 초기화?  / 함수 선언문은 함수 객체로 초기화해서 함수 호이스팅에 의해 호출이 가능하다
        
- 함수의 매개변수 개수보다 적은 인수를 전달하면 어떻게 되나요?
    - function add(x, y) → add(2) // y = undefined
    - 반대로 초과하면? → 무시된다… but 버려지진 않고 arguments 객체 프로퍼티에 저장됨.
- 콜백 함수란 무엇이며, 언제 사용하나요?
    - 함수의 매개변수로 다른 함수가 전달됨
    - 비동기 처리, 배열 고차 함수(map, reduce, filter…)
- 자바스크립트에서 "일급 객체(First-Class Citizen)"란 무엇이며, 함수가 일급 객체라는 것은 어떤 의미인가요?
    - 다음 장에서..

### 13장 스코프

- "렉시컬 스코프(Lexical Scope)"와 "동적 스코프(Dynamic Scope)"의 차이는 무엇인가요?
    - 렉시컬 스코프: 함수의 정의된 위치 - 자바스크립트 등 대부분 프로그래밍 언어
    - 동적 스코프: 함수가 호출되는 시점 - Perl?
- 자바스크립트의 스코프 체인이란 무엇인가요?
    - 스코프들이 계층적으로 연결된 것 → 변수를 참조할 때 상위 스코프 방향으로 이동해 변수를 검색함
- 함수 레벨 스코프와 블록 레벨 스코프의 차이점은 무엇인가요?
    - 함수 레벨 : 함수에 의해서만 지역 스코프가 생성됨. → var
    - 블록레벨: 모든 코드 블록(if, for … )에 의해 지역 스코프가 생성됨. → let, const

### 14장 전역 변수의 = 문제점

- 전역 변수를 사용할 때 발생하는 문제점은 무엇인가요?
    - 암묵적 결합, 결함
    - 생명 주기가 김 → 메모리를 오래 잡아먹음
    - 스코프 체인의 종점에 존재함 → 변수 검색 속도 제일 느림…
    - 네임스페이스 오염 → 다른 파일에 있는 전역변수까지 공유됨….
- 전역 변수를 최소화하는 방법에는 무엇이 있을까요?
    - 즉시 실행 함수
    - 네임스페이스 객체 사용
    - 모듈 패턴 사용
    - ES6 모듈 사용

### 15장 **let, const 키워드와 블록 레벨 스코프**

- 원시 값은 변경이 불가능한데, 왜 `const`로 선언한 객체는 내부 값을 변경할 수 있을까요?
    - 종훈리: 재할당이 불가능해서?
    - const는 재할당이 불가능, 객체는 재할당으로 바꾸는게 아님
- 각 키워드는 언제 사용하는게 좋은가요?
    - 일단 const로 써 생각하지 말고! 근데 코드 짜다보니… 이 녀석 변경이 꼭 필요한 변수임.. 그 때 제한적으로 let 바꿔!
    - var는 너가 ES6 이상 사용한다면 쓰.지.마!!

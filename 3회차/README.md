# ⭐️ QUIZ

## 16장 프로퍼티 어트리뷰트

- 내부 슬롯과 내부 메서드는 무엇이며, 직접 접근이 불가능한 이유는 무엇인가요?
    - 종훈리: 자바스크립트 내부에서 동작, 직접 호출할 수 있는 방법이 없다
    - 히범: 내부 슬롯: 의사프로퍼티 / 내부 메서드: 의사메서드
- Object.getOwnPropertyDescriptor() 메서드는 어떤 역할을 하나요?
    - 이소: 객체의 프로퍼티 상태? (객체, 프로퍼티 키) / value, writable, enumerable, configurable
- 데이터 프로퍼티와 접근자 프로퍼티의 차이점은 무엇인가요?
    - 채온: 일반적인 프로퍼티 / 접근자: 데이터 호출 시 필요한 프로퍼티
- Object.defineProperty() 메서드를 사용하여 프로퍼티의 속성을 변경하는 방법을 설명해주세요.
    - 히범: 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존에 있던 프로퍼티 어트리뷰트를 재정의할 때 쓴다.
    - 사용 방법은 첫 매개변수는 객체, 두 번째는 프로퍼티 이름(문자열) 세 번째는 프로퍼티 어트리뷰트를 객체로 싸서 넣어주면 됩니다!
    
    ```jsx
    const person = {}
    
    Object.defineProperty(person, 'name', {
    	value: '종훈',
    	writable: true,
    })
    
    // {value: '종훈', writable: true, enumerable: false, configurable: false} 
    ```
    
- 자바스크립트에서 객체 변경을 방지하는 방법에는 어떤 것이 있나요? 각각의 차이점은 무엇인가요?
    - 종훈리: Object.freeze(), Object.preventExtensions(), Object.seal() / 각각은 객체 변경 방지의 범위가 다르다.
- 불변 객체는 무엇이며, 구현 방법을 간단히 설명하세요.
    - 이소: 원래 객체 변경 시 중첩 객체까지 영향을 주지 않는다. 중첩 객체까지 영향을 주기 위해 깊은 변경 방지로 재귀적으로 Object.freeze() 메서드 사용
    - 히범: 객체는 원래 변경 가능한 값, 변경이 불가능하게 만드는 게 불변 객체
- 접근자 프로퍼티가 필요한 이유에 대해 설명하세요.
    - 채온: 데이터 프로퍼티의 값을 저장하거나 호출할 때 필요하다.
    - 히범: 누구나 객체 프로퍼티에 접근해서 값을 변경할 수 있다면 정보보호에 취약해질 수 있기 때문에 캡슐화를 진행. 허용한 프로퍼티에 한해서 접근하도록 접근자 프로퍼티가 필요한 것. JS의 경우 속성 앞에 키워드를 사용하는데, 이를 통해 접근 권한을 제한한다.
    
<br/>
<br/>


## 17장 생성자 함수에 의한 객체 생성

- 객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이점은 무엇인가요?
    - 종훈리: 리터럴: 하나만 생성 가능, 여러 개 비효율적 / 생성자: 여러 개 객체를 효율적으로, new 연산자
- new 연산자를 사용했을 때 생성자 함수가 실행되는 과정은 어떻게 되나요?
    - 이소: 일단 인스턴스 생성과 this 바인딩됩니다. 그 다음에 this 바인딩된 인스턴스를 초기화시킵니다. 그 다음에 인스턴스가 반환이 됩니다.
    - 히범: this 바인딩된 인스턴스를 암묵적으로 반환하는 것은 전달받은 초기값을 통해 갓 만든 객체를 this가 가리키고 있는 값을 반환하는 것
    
    ```jsx
    function Person(name) {
      console.log(this); // Person {}
    
      this.name = name;
      this.getName = function () {
        return `Hi, My Name is ${this.name}`
      }
    }
    ```
    
- 내부 메서드 [[Call]]과 [[Construct]]를 갖는 특수한 객체는 무엇이며 각 기능에 대해 설명하세요.
    - 채온: callable: 호출 가능한 객체 = 함수, constructor: 생성자 함수, 호출 가능
- 자바스크립트에서 constructor와 non-constructor 함수의 차이점은 무엇인가요?
    - 히범: 컨스럭터는 생성자 함수로써 호출될 수 있는 함수 객체이고 논 뭐시기는 그렇지 못한 함수객체이다. js에서 컨스트럭터로 작동하는 객체는 함수 객체 중에 함수 선언문 표현식 클래스
    논 컨스트럭터로 분류되는 것은 화살표함수랑 메서드 축약 표현 이렇게 됩니다..
- 함수 선언문과 함수 표현식으로 정의된 함수는 생성자 함수로 사용할 수 있나요?
    - 종훈리: 네!
- new 연산자 없이 생성자 함수를 호출했을 때 발생하는 문제는 무엇인가요? 이를 방지하는 방법은?
    - 이소: new 연산자를 썼는지 확인하기 위해 target 메서드를 사용해야 합니다.
    - 히범: 일반 함수가 호출되어 개발자의 의도와 다르게 코드가 실행된다. 이를 막기 위해 new.target을 써서 방지해야 한다.

<br/>
<br/>

## 18장 함수와 일급 객체

- 자바스크립트에서 함수가 일급 객체라는 의미는 무엇인가요?
    - 히범: 4가지 조건이 있죠
        1. 무명 리터럴로 생성 가능해야함
        2. 변수나 자료구조에 저장 가능해야함.
        3. 함수 매개변수로 전달 가능해야함.
        4. 함수 반환값으로 사용 가능해야함.
- 자바스크립트의 함수 객체가 가지는 주요 프로퍼티(arguments, caller, length, name, prototype)의 역할을 설명해주세요.
    - 종훈리: argument: 인수들의 정보를 담고 있는 객체 값 / caller: 함수 자신을 호출한 함수를 가리킨다. / length: 함수 정의 시 선언한 매개변수의 개수를 나타낸다. / name: 함수 이름 / prototype: 객체지향 프로그래밍의 상속을 구현하는 프로토타입 객체 값을 나타낸다.
- 함수 객체의 prototype 프로퍼티는 어떤 역할을 하나요?
    - 이소: 상속 구현

<br/>
<br/>

## 19장 프로토타입

- 자바스크립트의 객체지향 프로그래밍 방식과 클래스 기반 언어의 차이점은 무엇인가요?
    - 채온: 객체: 프로토타입 기반으로 상속 / 클래스: 클래스 → 인스턴스 생성
    - 종훈리: [참고 자료](https://breath-in317.tistory.com/entry/JavaScript%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98-vs-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B8%B0%EB%B0%98)
      
- 프로토타입 기반 상속이란 무엇이며, 어떤 방식으로 동작하나요?
    - 히범: 모든 객체는 prototype 프로퍼티를 갖는데 이를 기반으로 상속하여 … 구현한다.
    - 그니까 쉽게 말하면 클래스 → 인스턴스(객체)를 만들면서 그 자체로 부모 클래스 자식 클래스의 역할을 맡아서 상속도 해줌.
    - 프로토타입은 → 상속만 관여 인스턴스를 만든진 않음.
    - 생성자 함수 → 인스턴스(객체)만 만듦. 상속에 관여 하지 않음. (265p 참고)
 
     ![11111](https://github.com/user-attachments/assets/267a670e-dbac-4a25-b1ad-1604e4e9590c)

        
        
- proto 접근자 프로퍼티와 prototype 프로퍼티의 차이점은 무엇인가요?
    - 종훈리: 소유하는 객체, 생성 방법
- 리터럴 표기법으로 생성된 객체의 프로토타입은 어떻게 결정되나요?
    - 이소: constructor 가 가리키는 생성자 함수가 객체를 생성한 생성자 함수라고 단정할 수 없다.
    - 히범: 리터럴로 객체 생성하면 실제로는 생성자 함수가 객체를 생성한거는 아님!
    그러나 상속이란 개념을 사용하기 위해서 그냥 생성자 함수가 생성했다손 처!
    ex) 객체 리터럴로 객체 만들면 내부적으로 빌트인 생성자 함수인 Object가 생성했다고 치자!
     그러면 객체 리터럴로 만든 객체의 프로토타입이 Object.prototype이 되고 우린 상속의 개념을 사용할 수 있잖아!
- 프로토타입 체인이란 무엇이며, 어떻게 동작하나요?
    - 채온: 프로토타입 체인은 프로토타입이 없으면 부모를 검색하고, 없으면 또 상위로 이동하며 검색하는 것, 만약 최상위 프로퍼티(Object.prototype)가 없다면 undefined를 반환한다.
- 프로퍼티 섀도잉과 오버라이딩은 무엇인가요?
    - 히범: 프로토타입 메서드를 인스턴스 메서드에서 재정의하는 것을 오버라이딩이라고 하며 이때 프로토타입 메서드는 인스턴스 메서드에 의해 덮어씌어지는 것이 아닌 인스턴스 메서드에 의해 가려지는 현상을 프로퍼티 섀도잉이라고 함.
- JS에서 객체를 생성하는 방식은 무엇이 있으며 이들의 공통점은 무엇일까요?
    - 종훈리: 객체 리터럴 Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스 방법이 있다. 각 방법들은 생성 방식의 차이가 있지만 추상 연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.
- 생성자 함수를 통한 프로토타입 교체 시 주의 할 점은?
    - 이소: constructor 생성자 함수 간의 연결이 끊어짐 → 따라서 교체한 객체 리터럴에 constructor 추가해줘야해
- 생성자 함수를 통한 프로토타입 교체와 인스턴스에 의한 프로토타입의 차이점은?
    - 채온: 생성자 함수: 새로운 객체 리터럴로 교체 가능 / 인스턴스: __proto__, Object.setPrototypeOf 로 교체 가능
- Object.create()를 사용한 객체 상속의 장점은 무엇인가요?
    - 히범: 아주 좋은 녀석이다. 직접 상속을 할 때 사용하는데 new 연산자 없이 객체를 생성할 수 있고, prototype을 지정하면서 객체를 지정할 수 있고, 객체 리터럴을 통해 생성한 객체도 상속받을 수 있다.
- instanceof 연산자는 어떤 원리로 객체의 타입을 판별하나요?
    - 종훈리:  instanceof 연산자는 이항 연산자로서 좌변과 우변의 값에 따라 연산을 처리함. 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true, 그렇지 않다면 false를 반환한다.
- 정적(static) 메서드와 인스턴스 메서드의 차이는 무엇인가요?
    - 이소: 일단 표기법에서 차이가 납니다. 정적 메서드는 인스턴스로 접근할 수 없습니다. 그리고 인스턴스 메서드는 prototype 체인에 속한 객체에 접근할 수 있습니다.
- 객체의 프로퍼티 존재 여부를 확인하는 방법에는 어떤 것들이 있나요?
    - 채오니: in 연산자: 프로토타입 체인에 있는 프로퍼티도 검색 가능 / Object.prototype.hasOwnProperty() 메서드: 상속받은 프로퍼티는 확인하지 않음

<br/>
<br/>

## 20장 strict mode

- strict mode를 적용하는 방법과 적용 시 주의할 점은 무엇인가요?
    - 히범: 전역의 선두 or 함수 몸체의 선두 `use strict` / 선두에 위치!
- strict mode를 전역에 적용하는 것이 비추천되는 이유는 무엇인가요?
    - 종훈리: 스크립트 단위로 적용되는데, 이렇게 되면 다른 스크립트에 영향을 주지 않기 때문에 오류가 발생할 수 있음
- strict mode에서 발생하는 주요 에러 사례(암묵적 전역, 변수 삭제, 매개변수 중복 등)를 설명해주세요.
    - 이소: ReferceError / SyntaxError / SyntaxError
- strict mode에서 일반 함수의 this 바인딩이 어떻게 변경되나요?
    - 채온:  undefined로 바인딩됩니다. 일반 함수에서 this 바인딩을 할 필요가 없기 때문입니다.
- strict mode에서 arguments 객체의 동작 방식은 어떻게 달라지나요?
    - 히범: 매개변수에 전달된 인수를 재할당해도 argument 객체에는 반영되지 않습니다.

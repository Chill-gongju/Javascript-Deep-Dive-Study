## 16장. 프로퍼티 어트리뷰트

### 16.1 내부 슬롯과 내부 메서드

내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다. 
내부 슬롯과 내부 메서드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.

### 16.2 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다.
```js
const person = {
    name: 'Lee';
};
console.log(Object.getOwnPropertyDescriptor(person, 'name'));
```
프로퍼티 어트리뷰트로 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.

### 16.3 데이터 프로퍼티와 접근자 프로퍼티

프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.
- 데이터 프로퍼티: 키와 값으로 구성된 일반적인 프로퍼티
- 접근자 프로퍼티: 자체적으로는 값을 갖고 있지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티
데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티를 갖고, 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티를 갖는다.

### 16.4 프로퍼티 정의

프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.
예를 들어 Object.defineProperty 메서드를 사용하여 프로퍼티의 어트리뷰트를 정의할 수 있다.

### 16.5 객체 변경 방지

객체는 변경 가능한 값이므로 재할당 없이 직접 변경할 수 있다. 즉, 프로퍼티를 추가, 삭제할 수 있고 프로퍼티 값을 갱신할 수 있으며 재정의할 수도 있다.
자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다.
- 객체 확장 금지: Object.preventExtensions, 확장이 금지된 객체는 프로퍼티 추가가 금지된다.
- 객체 밀봉: Object.seal, 밀봉된 객체는 읽기와 쓰기만 가능하다.
- 객체 동결: Object.freeze, 동결된 객체는 읽기만 가능하다.
- 불변 객체: 상단의 변경 방지 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 않는다. 따라서 불변 객체를 구현하려면 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메서드를 호출해야 한다.

---

## 17장. 생성자 함수에 의한 객체 생성

### 17.1 Object 생성자 함수

new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수도 있다.

### 17.2 생성자 함수

- 객체 리터럴에 의한 객체 생성 방식은 간편하지만 단 하나의 객체만 생성한다는 문제점이 있다. 또한 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적이다.
- 이때 생성자 함수를 통해 객체를 생성하면 여러 개의 객체를 간편하게 생성할 수 있다. 생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다. 하지만 자바와 같은 클래스 기반 객체지향언어의 생성자와는 다르게 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다.
- 생성자 함수의 인스턴스 생성 과정은 다음과 같다.
1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환
- 함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다. 함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
- 자바스크립트 엔진은 constructor와 non-constructor를 다음과 같이 구분한다.
1. constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)
2. non-constructor: 메서드, 화살표 함수
- 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 다시 말해, 함수 객체의 내부 메서드 call이 호출되는 것이 아니라 construct가 호출된다.

---

## 18장. 함수와 일급 객체

### 18.1 일급 객체

다음과 같은 조건을 만족하는 객체를 일급 객체라 한다.
1. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 함수의 반환값으로 사용할 수 있다.
자바스크립트의 함수는 위의 조건을 모두 만족하므로 일급 객체다.

### 18.2 함수 객체의 프로퍼티

함수는 객체이므로 프로퍼티를 가질 수 있다. 
```js
function square(number){
    return number * number;
}
console.dir(square);
```
arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티다. 
1. arguments: arguments 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 지역 변수처럼 사용된다.
2. caller: caller는 비표준 프로퍼티다. 함수 자신을 호출한 함수를 가리킨다.
3. length: length는 함수를 정의할 때 선언한 매개변수의 개수를 가리킨다.
4. name: name은 함수 이름을 나타낸다.
5. prototype: 모든 객체는 prototype이라는 내부 슬롯을 갖는다. 이는 객체지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.

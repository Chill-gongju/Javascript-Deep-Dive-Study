## 26장. ES6 함수의 추가 기능

### 26.1 함수의 구분

- ES6 이전까지 자바스크립트의 함수는 별다른 구분 없이 다양한 목적으로 사용되었다. 하지만 다양한 목적이 있음에도 실수를 유발시킬 수 있으며 성능 면에서도 손해다.
```js
var foo = function(){
    return 1;
};
foo(); // 일반 함수로서 호출

new foo(); // 생성자 함수로서 호출
var obj = { foo: foo }; // 메서드로서 호출
obj.foo();
```
- 이처럼 ES6 이전의 함수는 사용 목적에 따라 명확히 구분되지 않는다. 즉, ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 이때 호출 방식에 특별한 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성한다. 이는 혼란스러우며 실수를 유발할 가능성이 있고 성능에도 좋지 않다.

### 26.2 메서드

- ES6 이전 사양에는 메서드에 대한 명확한 정의가 없었다. ES6 사양에서는 메서드에 대한 정의가 명확하게 규정되었다. ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.
- ES6 사양에서 정의한 메서드는 인스턴스를 생성할 수 없는 non-constructor다. 따라서 ES6 메서드는 생성자 함수로서 호출할 수 없다.
- ES6 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.
- ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.

### 26.3 화살표 함수

- 화살표 함수는 function 키워드 대신 =>를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의할 수 있다. 화살표 함수는 표현만 간략한 것이 아니라 내부 동작도 기존의 함수보다 간략하다.
- 화살표 함수의 정의 문법은 다음과 같다.
1. 함수 정의
화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다. 호출 방식은 기존 함수와 동일하다.
```js
const multiply = (x, y) => x * y;
multiply(2, 3);
```
2. 매개변수 선언
매개변수가 여러 개인 경우 소괄호 안에 매개변수를 선언한다.
매개변수가 한 개이거나 없는 경우 소괄호를 생략할 수 있다.
3. 함수 몸체 정의
함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호를 생략할 수 있다. 
- 화살표 함수와 일반 함수의 차이는 다음과 같다.
1. 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
2. 중복된 매개변수 이름을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 this, arguments, super, new, target 바인딩을 갖지 않는다.
- 화살표 함수가 일반 함수와 구별되는 가장 큰 특징은 바로 this다. 화살표 함수의 this는 일반 함수의 this와 다르게 동작한다. 이는 콜백 함수 내부의 this가 외부 함수의 this와 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다. 
- this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다.
- 화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라 한다. 이는 마치 렉시컬 스코프와 같이 화살표 함수의 this가 함수가 정의된 위치에 의해 결정된다는 것을 의미한다.
- 화살표 함수는 함수 자체의 super, arguments 바인딩을 갖지 않는다. 따라서 화살표 함수 내부에서 super, arguments를 참조하면 this, arguments와 마찬가지로 상위 스코프의 super, arguments를 참조한다.

### 26.4 Rest 파라미터

- Rest 파라미터는 매개변수 이름 앞에 세개의 점 ...을 붙여서 정의한 매개변수를 의미한다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다. 
```js
function foo(...rest){
    console.log(rest);
};
foo(1,2,3,4,5);
```
- 일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다. 이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다. 
- Es5에서는 함수를 정의할 때 매개변수의 개수를 확정할 수 없는 가변 인자 함수의 경우 매개변수를 통해 인수를 전달받는 것이 불가능하므로 arguments 객체를 활용하여 인수를 전달받았다. arguments 객체는 함수 호출 시 전달된 인수들의 정보를 담고 있는 순회 가능한 유사 배열 객체이며, 함수 내부에서 지역 변수처럼 사용할 수 있다. 
- ES6에서는 rest 파라미터를 사용하여 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있다. 이를 통해 유사 배열 객체인 arguments 객체를 배열로 반환하는 번거로움을 피할 수 있다.

### 26.5 매개변수 기본값

- 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 바람직하지만 그렇지 않은 경우에도 에러가 발생하지 않는다. 이는 자바스크립트 엔진이 매개변수의 개수와 인수의 개수를 체크하지 않기 때문이다.
- 인수가 전달되지 않은 매개변수의 값은 undefined다. 이를 방치하면 다음 예제와 같이 의도치 않은 결과가 나올 수 있다.
```js
function sum(x, y){
    return x + y;
}
console.log(sum(1));
```

---

## 27장. 배열

### 27.1 배열이란?

- 배열은 여러 개의 값을 순차적으로 나열한 자료구조다. 
```js
const arr = ['종', '훈', '리'];

arr[0]; // 종
arr[1]; // 훈
arr[2]; // 리

arr.length // 3
```
- 배열이 가지고 있는 값을 요소라고 부른다. 원시값은 물론 객체, 함수, 배열 등 자바스크립트에서 인정하는 모든 것은 배열의 요소가 될 수 있다.
- 배열의 요소는 배열에서 자신의 위치를 나타내는 0 이상의 정수인 인덱스를 갖는다.
- 배열은 요소의 갯수, 즉 배열의 길이를 나타내는 length 프로퍼티를 갖는다.
- 배열은 객체지만 일반 객체와는 구별되는 독특한 특징이 있다.
구분            |          객체            | 배열
구조            |  프로퍼티 키와 프로퍼티 값 | 인덱스와 요소
값의 참조       |        프로퍼티 키        | 인덱스
값의 순서       |            X             | O
length 프로퍼티 |            X             | O

### 27.2 자바스크립트 배열은 배열이 아니다

- 배열의 요소는 하나의 데이터 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열이라 한다.
- 일반적인 의미의 배열은 각 요소가 동일한 데이터 크기를 가지며, 빈틈없이 연속적으로 이어져 있으므로 인덱스를 통해 단 한 번의 연산으로 임의의 요소에 접근할 수 있다. 이는 매우 효율적이며 고속으로 동작한다.
- 이처럼 배열은 인덱스를 통해 효율적으로 요소에 접근할 수 있다는 장점이 있다. 하지만 정렬되지 않은 배열에서 특정한 요소를 검색하는 경우 배열의 모든 요소를 처음부터 특정 요소를 발견할 때까지 차례대로 검색해야 한다.(시간 복잡도)
- 자바스크립트의 배열은 일반적인 의미의 배열과 다르다. 즉, 배열의 요소를 위한 각각의 메모리 공간은 동일한 크기를 갖지 않아도 되며, 연속적으로 이어져 있지 않을 수도 있다. 배열의 요소가 연속적으로 이어져 있지 않는 배열을 희소 배열이라 한다.

### 27.3 length 프로퍼티와 희소 배열

- length 프로퍼티는 요소의 개수, 즉 배열의 길이를 나타내는 0 이상의 정수를 값으로 갖는다. length 프로퍼티의 값은 빈 배열일 경우 0이며, 빈 배열이 아닐 경우 가장 큰 인덱스에 1을 더한 것과 같다.
- length 프로퍼티의 값은 배열에 요소를 추가하거나 삭제하면 자동 갱신되며 프로퍼티 값보다 작은 숫자 값을 할당하면 배열의 길이가 줄어든다.
- 배열의 요소가 연속적으로 위치하지 않고 일부가 비어 있는 배열을 희소 배열이라 한다. 자바스크립트는 희소 배열을 문법적으로 허용한다.
- 희소 배열은 length와 배열 요소의 개수가 일치하지 않는다. 희소 배열의 length는 희소 배열의 실제 요소 개수보다 언제나 크다.
- 배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선이다.

### 27.4 배열 생성

- 객체와 마찬가지로 배열도 다양한 생성 방식이 있다.
1. 배열 리터럴: 가장 일반적인 방식
```js
const arr = [1, 2, 3];
console.log(arr.length);
```
2. Array 생성자 함수
```js
const arr = new Array(10);
console.log(arr);
console.log(arr.length);
```
3. Array.of
ES6에서 도입된 Array.of 메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.
```js
Array.of(1);
Array.of(1, 2, 3);
```
4. Array.from
ES6에서 도입된 Array.from 메서드는 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.
```js
Array.from({length: 2, 0: 'a', 1: 'b'});
Array.from('hello');
```

### 27.5 배열 요소의 참조

- 배열의 요소를 참조할 때는 [] 표기법을 사용한다. 대괄호 안에는 인덱스가 와야 한다.
- 존재하지 않는 요소에 접근하면 undefined가 반환된다.

### 27.6 배열 요소의 추가와 갱신

- 객체에 프로퍼티를 동적으로 추가할 수 있는 것처럼 배열에도 요소를 동적으로 추가할 수 있다. 존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가된다.
- 만약 현재 배열의 length 프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다.

### 27.7 배열 요소의 삭제

- 배열은 사실 객체이기 때문에 배열의 특정 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다.

### 27.8 배열 메서드

- 자바스크립트는 배열을 다룰 때 유용한 다양한 빌트인 메서드를 제공한다.
- 배열에는 원본 배열을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.
1. Array.isArray : Array 생성자 함수의 정적 메서드
2. Array.prototype.indexOf : indexOf 메서드는 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다. 배열에 특정 요소가 있는지 확인할 때 유용하다.
3. Array.prototype.push: push 메서드는 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환하다. push 메서드는 원본 배열을 직접 변경한다.
4. Array.prototype.pop : pop 메서드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. pop 메서드도 원본 배열을 직접 변경한다.
5. Array.prototype.unshift: unshift 메서드는 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. unshift 메서드는 원본 배열을 직접 변경한다.
6. Array.prototype.shift : shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. shift 메서드는 원본 배열을 직접 변경한다.
7. Array.prototype.concat: concat 메서드는 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 원본 배열은 변경되지 않는다.
8. Array.prototype.splice: 원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는 경우 splice 메서드를 사용한다. splice 메서드는 원본 배열을 직접 변경한다.
9. Array.prototype.slice: slice 메서드는 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. 원본 배열은 변경되지 않는다.
10. Array.prototype.join: join 메서드는 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열, 즉 구분자로 연결한 문자열을 반환한다.
11. Array.prototype.reverse: reverse 메서드는 원본 배열의 순서를 반대로 뒤집는다. 이때 원본 배열이 변경된다.
12. Array.prototype.fill: fill 메서드는 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다. 이때 원본 배열이 변경된다.
13. Array.prototype.includes: includes 메서드는 배열 내에 특정 요소가 포함되어 있는지 확인하여 true, false를 반환한다.
14. Array.prototype.flat: flat 메서드는 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화한다.

### 27.9 배열 고차 함수

- 고차 함수는 함수를 인자로 전달받거나 함수를 반환하는 함수를 말한다.
- 고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.
- 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.
1. Array.prototype.sort: sort 메서드는 배열의 요소를 정렬한다. 원본 배열을 직접 변경하며 정렬된 배열을 반환한다.
2. Array.prototype.forEacth: forEach 메서드는 for 문을 대체할 수 있는 고차 함수다. 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출한다.
3. Array.prototype.map: map 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.
4. Array.prototype.filter: filter 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. 그리고 콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환한다. 이때 원본 배열은 변경되지 않는다.
5. Array.prototype.reduce: reduce 메서드는 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환한다.
6. Array.prototype.some: some 메서드는 콜백 함수의 반환값이 단 한 번이라도 참이면 true, 모두 거짓이면 false를 반환한다.
7. Array.prototype.every: every 메서드는 콜백 함수의 반환값이 모두 참이면 true, 하나라도 거짓이면 false를 반환한다.
8. Array.prototype.find: find 메서드는 콜백 함수의 반환값이 true인 요소가 존재하지 않는다면 undefined를 반환한다.
9. Array.prototype.findIndex: findIndex 메서드는 콜백 함수의 반환값이 true인 요소가 존재하지 않는다면 -1을 반환한다.
10. Array.prototype.flatMap: flatMap 메서드는 map 메서드를 통해 생성된 새로운 배열을 평탄화한다. 즉, map 메서드와 flat 메서드를 순차적으로 실행하는 효과가 있다.

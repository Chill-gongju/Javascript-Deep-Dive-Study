# 46장. 제너레이터와 async/await

### 제너레이터

> ES6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

### 제너레이터와 일반 함수의 차이점

1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.

2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.

3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.

### 제너레이터 함수

- `function*` 키워드로 선언함
- 하나 이상의 yield 표현식을 포함

### 제너레이터 객체

제너레이터 함수를 호출하면 일반 함수처럼 코드 블록을 실행하는 것이 아니라, 제너레이터 객체를 생성해 반환한다.

```js
// 제너레이터 함수
function* genFunc() {
  yield 1;
  yield 2;
  yield 3;
}

// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
const generator = genFunc();

// 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.
// 이터러블은 Symbol.iterator 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체다.
console.log(Symbol.iterator in generator); // true
// 이터레이터는 next 메서드를 갖는다.
console.log('next' in generator); // true
```

### async/await

ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기처럼 동작할수록 구현할 수 있는 async/await가 도입되었다. async/await는 프로미스를 기반으로 동작한다.

- async/await를 사용하면 프로미스의 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.

#### 1. asnyc 함수

- await 키워드는 반드시 async 함수 내부에서 사용해야 한다.
- async 함수는 async 키워드를 사용해 정의하며, 언제나 프로미스를 반환한다.
- async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 반환값을 resolve하는 프로미스를 반환한다.

```js
// async 함수 선언문
async function foo(n) {
  return n;
}
foo(1).then((v) => console.log(v)); // 1

// async 함수 표현식
const bar = async function (n) {
  return n;
};
bar(2).then((v) => console.log(v)); // 2

// async 화살표 함수
const baz = async (n) => n;
baz(3).then((v) => console.log(v)); // 3

// async 메서드
const obj = {
  async foo(n) {
    return n;
  },
};
obj.foo(4).then((v) => console.log(v)); // 4

// async 클래스 메서드
class MyClass {
  async bar(n) {
    return n;
  }
}
const myClass = new MyClass();
myClass.bar(5).then((v) => console.log(v)); // 5
```

#### 2. await 키워드

- await 키워드는 프로미스가 settled가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolved한 처리 결과를 반환한다.
- await 키워드는 반드시 프로미스 앞에서 사용해야 한다.

<br/>
<br/>

# 47장. 에러 처리

### 에러 처리의 필요성

- 에러가 발생하지 않는 코드를 작성하는 것은 불가능하다.
- 발생한 에러에 대처하지 않고 방치하면 프로그램이 강제 종료된다.
- `try...catch` 문을 사용해 에러에 적절히 대응할 수 있다.
- 언제나 에러나 예외적인 상황이 발생할 수 있다는 것을 전제하고 이에 대응하는 코드를 작성하는 것이 중요하다.

### try...catch...finally문

```js
try {
  // 실행할 코드
} catch (err) {
  // try 코드 블록에서 에러가 발생하면 이 코드 블록의 코드가 실행
  // err에는 Error 객체가 전달
} finally {
  // 에러 발생과 상관없이 반드시 한 번 실행
}
```

### Error 객체

- Error 생성자 함수는 에러 객체를 생성한다.
- Error 생성자 함수에는 에러를 설명하는 에러 메시지를 인수로 전달할 수 있다.
- Error 객체는 message 프로퍼티와 stack 프로퍼티를 갖는다.
  - `message 프로퍼티의 값`: Error 생성자 함수에 인수로 전달한 에러 메시지
  - `stack 프로퍼티의 값`: 에러를 발생시킨 콜스택의 호출 정보를 나타내는 문자열

### throw문

- Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다
- 에러를 발생시키려면 try 코드 블록에서 throw 문으로 에러 객체를 던져야 한다.

```js
try {
  // 에러 객체를 던지면 catch 코드 블록이 실행되기 시작한다.
  throw new Error('something wrong');
} catch (error) {
  console.log(error);
}
```

### 에러의 전파

- 에러는 호출자 방향으로 전파된다. 즉, 에러는 콜스택의 아래 방향으로 전파된다.

<br/>
<br/>

# 48장. 모듈

### 모듈

- 모듈이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다.
- 모듈이 성립하려면 모듈은 자기만의 모듈 스코프를 가져야한다.

모듈의 리소스는 기본적으로 비공개 상태이다. 즉, 개별적 존재로 애플리케이션과 분리되어 있지만 이런 모듈은 재사용이 불가능하므로 존재 의미가 없다.
따라서, 모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 한다.

### 자바스크립트와 모듈

- 원래 자바스크립트는 모듈 시스템을 지원하지 않았다. 그래서 script 태그로 불러온 여러 스크립트들은 마치 하나의 파일안에 작성된 코드들처럼 동작한다.
- 하지만 자바스크립트 런타임 환경인 Node.js는 모듈 시스템의 표준인 CommonJS 사양을 따르고 있다.
- 즉, Node.js는 ECMAScript 표준 사양은 아니지만 모듈 시스템을 지원한다.
- 따라서 Node.js 환경에서는 파일별로 독립적인 모듈 스코프를 갖는다.

### ES6 모듈 (ESM)

ES6에서 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가했다. ES6 모듈이 사용법은 간단하다.

- script 태그에 `type='module'` 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로 동작한다.
- ESM에서는 기본적으로 strict mode가 적용된다.

#### 모듈 스코프

ESM은 독자적인 모듈 스코프를 제공한다.

모듈 내에서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.

#### 1. export 키워드

모듈 내부에서 선언한 식별자를 외부에 공개하여 다른 모듈들이 재사용할 수 있게 하려면 export 키워드를 사용한다.

#### 2. import 키워드

다른 모듈에서 공개한 식별자를 자신의 모듈 스코프 내부로 로드하려면 import 키워드를 사용한다.

- 모듈이 export한 식별자 이름을 일일이 지정하지 않고 하나의 이름으로 한 번에 import할 수도 있다. `*`
- 모듈이 export한 식별자 이름을 변경하여 import할 수도 있다.
- 모듈에서 하나의 값만 export한다면 default 키워드를 사용할 수 있다.
  - default 키워드를 사용하는 경우 기본적으로 이름 없이 하나의 값을 export 한다.
  - default 키워드를 var, let, const 키워는 사용할 수 없다.

<br/>
<br/>

# 49장. Babel과 Webpack을 이용한 ES6+/ES.NEXT 개발 환경 구축

ES6+와 ES.NEXT의 최신 ECMAScript 사양을 사용하여 프로젝트를 진행하려면 최신 사양으로 작성된 코드를 경우에 따라 구형 브라우저에서 문제 없이 동작시키기 위한 개발 환경을 구축해야 될 필요가 있다.

또한, 프로젝트가 모듈을 사용하므로 모듈 로더도 필요하다. 다음과 같은 이유로 ESM보다는 별도의 모듈 로더를 사용하는 것이 일반적이다.

- IE를 포함한 구형 브라우저는 ESM을 지원하지 않는다.
- ESM을 사용하더라도 트랜스파일링이나 번들링이 필요하다.
- ESM이 아직 지원하지 않는 기능이 있고 해결되고는 있지만 아직 몇 가지 이슈가 존재한다.

### Babel - 트랜스파일러

> Babel은 ES6+/ES.NEXT로 구현된 최신 사양의 소스코드를 구형 브라우저에서도 동작하는 ES5 사양의 소스코드로 변환해준다.

### Webpack - 모듈 번들러

> Webpack은 의존 관계에 있는 자바스크립트, CSS, 이미지 등의 리소스들을 하나의 파일로 번들링하는 모듈 번들러다.

- Webpack을 사용하면 의존 모듈이 하나의 파일로 번들링되어서 별도의 모듈 로더가 필요 없다.
- 여러 개의 자바스크립트 파일을 하나로 번들링하므로, HTML 파일에서 script 태그로 여러 개의 자바스크립트 파일을 로드해야 하는 번거로움도 사라진다.

<br/>
<br/>

# 41장. 타이머

- 자바스크립트는 싱글 스레드인데, 어떻게 setTimeout 같은 타이머 함수가 비동기로 동작하나요?
    - 채온: 브라우저에서는 멀티로 작동해서 비동기? 정답!🔺
    - 자바스크립트는 싱글 스레드, 브라우저는 멀티 스레드로 동작, 브라우저와 자바스크립트 엔진이 협력하여 비동기 처리를 구현
- 디바운스와 스로틀의 차이를 설명해주세요. 각각 언제 사용하면 좋을까요?
    - 이소: 디바운스는 **일정 시간이 경과한 이후에** 
이벤트 핸들러를 한번만 호출하도록 함 ⇒ 입력 / 스로틀은 **일정 시간 간격으로** 이벤트…핸들러가 한 번만 호출하도록 한 다….→ 스크롤 이벤트…. 뭔차이,…?…………………………………….
    
     ![IMG_1543 JPEG](https://github.com/user-attachments/assets/cf712b6c-ed35-4e0f-bedb-3b12027144f2)
    ![IMG_1542 JPEG](https://github.com/user-attachments/assets/5698c70d-dec4-4d98-9e5e-1ce3dc0d6d55)
            
<br/>
<br/>



# 42장. 비동기 프로그래밍

- 동기 처리와 비동기 처리의 차이점은 무엇인가요? 자바스크립트에서는 왜 비동기 처리가 필요한가요?
    - 종훈: 동기 처리는 특정 task가 끝날때까지 기다렸다가 그 다음 task를 순차적으로 실행하는 것, 비동기는 순차적으로 실행하는게 아니라 앞의 task가 끝나지 않아도 그 다음 task를 실행하는 것
    - 비동기가 필요한 이유는 동기 처리만으로 실행이 되면 task가 쌓이고 블로킹되어서 비효율적이기 때문에
- `setTimeout(fn, 0)`과 `Promise.resolve().then(fn)`의 실행 순서는 어떻게 다르고, 그 이유는 무엇인가요?
    - 히범: 전자는 음.. 비동기가 일어나는데 해당 함수를 만나면 해당 함수의 실행 컨텍스트가 만드어지고 콜스택에 쌓임 그럼 해당 함수를 실행하고 해당 함수의 콜백 함수는 콜 스택이 아니라 태크스 큐에 들어가서 잠깐 대기! 콜 스택에 들어가 있는 모든 실행 컨텍스트들이 실행된 후 사라지면 그제서야 태스크 큐에 들어가서 대기하고 있던 태스크들이 이벤트루프에 의해 콜스택로 선입선출 방식으로 이동함!
    
    후자는 일단 프로미스안에 비동기 처리한 애들의 그그… 결과를 보고 처리가 성공하면 후속 처리 함수인 then으로 넘어가서 성공 시 실행되는 첫번째 매개변수로 받은 콜백함수가 마이크로태스크 큐에 쌓임 그리고 콜스택 비워지면 마이크로태스크 큐에서 대기하고 있던 애들이 콜 스택으로 이동해서 실행되는데 마이크로태스크 큐가 그냥 태스크 큐 보다 우선순위가 높아서 먼저 처리됨! 끝!
- 동기 처리와 비동기 처리의 각 장단점을 설명하세요
    - 채온
    - 동기 처리: 태스크를 순서대로 처리하므로 실행 순서가 보장, 앞선 태스크가 종료되기 전까지 이후 태스크들이 블로킹
    - 비동기 처리: 현재 실행중인 태스크가 종료되지 않은 상태여도 다음 태스크를 바로 실행해서 블로킹 일어나지 않음, 태스크 실행 순서를 보장하지 못함

<br/>
<br/>


# 43장. Ajax

- Ajax는 어떻게 동작하나요? XMLHttpRequest와 fetch의 차이는 무엇인가요?
    - 이소: XMLHttpRequest 기반으로 동작하는데, 비동기 방식으로 서버에게 요청한 데이터를 받아서 웹페이지를 동적으로 갱신하는 방식입니다. / XML fetch 차이점은 ….. 일단 fetch는 promise 기반이라서 더 간결하고 명확합니다.  콜백 패턴의 단점을 보완하므로 XML보다 더 나은 방식?인것 같습니다.
- JSON.stringify와 JSON.parse는 각각 어떤 상황에서 쓰이며, JSON의 데이터 타입 한계는 무엇인가요?
    - 종훈: stringify는 객체 → JSON(직렬화), parse는 JSON → 객체(역직렬화)
    - JSON의 데이터 타입 한계는 타입이 한정적이다.
    - JSON은 문자열, 숫자, boolean, null, 배열, 객체 등 기본적인 데이터 타입만 지원합니다. 복잡한 데이터 구조(예: 함수, 날짜, 특정 형식의 숫자)를 표현하기 위해서는 추가적인 처리(직렬화, 역직렬화)가 필요할 수 있습니다.


<br/>
<br/>

# 44장. REST API

- REST 아키텍처의 구성 요소 3가지를 설명해주세요. REST API가 일반 HTTP 통신보다 가지는 장점은 무엇인가요?
    - 히범: 자원 행위 표현 → 자원은 URI로 표현함. 행위는 HTTP 요청 메서드로 표현함. 표현은 페이로드로 표현함.
    ex. Get /todo/1 → 자원에 동사 쓰지 마센! 왜? URI는 리소스 표현에만 집중해야하고 행위에 대한 정의는 HTTP 요청 메서드로 하자~ 이것이 REST가 제안하고 있는 아주 중요한 HTTP 프로토콜 사용법?임!
- GET과 POST는 어떻게 다르고, PUT과 PATCH의 차이점은 무엇인가요?
    - 채온: get 데이터 조회, 페이로드 X / post 데이터 생성, 페이로드 O / put 데이터 전체 수정, 페이로드 O / **patch 부분 수정**, 페이로드 O


<br/>
<br/>

# 45장. 프로미스

- *~~프로미스~~*의 3가지 상태와 각 상태의 전이 조건을 설명해주세요.
    - 이소: pending - 수행되기 전의 상태, 수행되지 않은 상태 / fulfilled - 수행되어서 성공인 상태 / rejected - 수행되어서 실패인 상태
- `Promise.all`과 `Promise.race`, `Promise.allSettled`는 각각 어떤 상황에서 적합하게 사용되나요?
    - 종훈: all 메서드는 여러 개의 비동기 처리를 모두 병렬 처리할 때 / race: 가장 먼저 fulfilled된 프로미스의 결과를 반환할 때 / allSettled: 모두 settled 상태가 되면 결과를 배열로 반환한다.
- 프로미스에서 에러 처리는 어떻게 해야 하나요?
    - 히범: 에러처리! then의 두번째 매개변수로 처리할 수도 있고 catch로 캐치할 수도 있음! 그러나! catch를 쓰는게 권장되는데 그 이유는 then으로 처리하면 어… then에서 발생한 에러를 잡아주지 못함. 반면 catch는 모든 then 뒤에서 사용하면 모든 then에서 발생할 수 있는 에러를 잡아줄 수 있음! 그래서 catch 쓰자!
        
        -end-

<br/>
<br/>

## 끝이 보인다리~~~

![6e6819e7efb9daed1086ead18032b4e7](https://github.com/user-attachments/assets/101e8035-7b6b-4d73-b667-d9f71041698e)



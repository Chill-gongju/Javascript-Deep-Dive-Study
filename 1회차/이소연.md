# 4장. 변수

## 4.1. 변수는 무엇이고 왜 필요할까?

변수는 데이터를 관리하기 위해 사용된다.

- 컴퓨터는 CPU로 연산하고, 메모리로 데이터를 저장한다.

  메모리는 여러 개의 셀로 되어 있으며, 각 셀은 고유의 메모리 주소를 가진다.

  그러나 메모리 주소에 직접 접근하게 되면 오류가 발생할 가능성이 크며, 이 방식만으로는 CPU가 연산한 값을 재사용하기 어렵다.

> 따라서, 메모리에 저장된 값을 안전하게 재사용하기 위해 변수가 필요하다.

정리하면 변수란,

1. 값을 저장하기 위해 확보한 메모리 공간 자체
2. 메모리 공간을 식별하기 위한 이름
3. 저장된 값의 위치를 가리키는 식별자

즉, 변수를 사용하면 메모리 주소를 직접 접근할 필요 없이 안전하게 데이터에 접근할 수 있다.

## 4.2. 식별자

변수는 데이터를 저장하고 참조하기 위해 사용되며, 변수명은 식별자라고도 한다.

- 식별자는 메모리 주소를 통해 변수나 함수, 클래스 등을 구별하는데 사용된다.

  또한, 메모리 주소와 매핑 관계를 맺으며 이 매핑 정보 역시 메모리에 저장된다.

> 즉, 식별자는 값이 아니라 메모리 주소를 기억하고 있으며,

> 선언을 통해 자바스크립트 엔진이 식별자의 존재를 인식하게 된다.

## 4.3. 변수 선언

변수를 생성하는 것을 선언이라고 하는데, 이때 `var`, `let`, `const` 키워드를 사용한다.

- `var` 키워드는 함수 레벨 스코프를 가지며, 전역 변수가 선언되는 문제가 있다.

  이런 단점을 보완하기 위해 `let`, `const` 키워도가 도입되었다.

자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행햔다.

1. 선언 단계

   변수 이름을 등록해서 자바스크립트 엔진에 해당 변수의 존재를 알린다.

2. 초기화 단계

   값을 저장하기 위한 메모리 공간을 확보하고 **암묵적으로 undefined를 할당해 초기화한다.**

   만약 초기화 단계를 거치지 않으면, 이전에 할당된 쓰레기 값이 남아 있을 수 있다.

변수를 사용하려면 반드시 선언이 필요하며, 선언하지 않은 식별자에 접근하면 `ReferenceError`가 발생하게 된다.

### 변수 이름이 저장되는 곳은 실행 컨텍스트(Execution Context)

`실행 컨텍스트`는 코드의 실행 결과를 실제로 관리하는 영역으로, 자바스크립트 엔진이 여기서 식별자와 스코프를 관리한다.

실행 컨텍스트에서 변수 이름과 값은 키-값 형태로 등록되어 관리된다.

이러한 과정을 통해 자바스크립트 엔진은 변수를 올바르게 인식하고 관리할 수 있게 된다.

## 4.4. 변수 선언의 실행 시점과 변수 호이스팅

```js
console.log(score); // undefined

var score;
```

변수 선언이 이루어지기 전에 변수를 참조하면, `ReferenceError`가 발생하는 대신 `undefined`이 출력된다.

> 변수 선언은 코드가 실행되는 런타임이 아니라, 그 이전 단계에서 먼저 실행되기 때문이다.

자바스크립트 엔진은 코드를 한 줄씩 실행하기 전에, `코드의 평과 과정`을 거쳐 코드 실행을 준비한다.

이 평과 과정에서 모든 선언문을 먼저 실행한 후, 선언문을 제외한 코드들을 한 줄씩 순차적으로 실행한다.

> 즉, 자바스크립트 엔진은 변수 선언을 다른 코드보다 먼저 처리하므로, 변수의 위치와 상관없이 어디서든 변수를 참조할 수 있게 된다.

### 이렇게 변수 선언문이 코드 맨 위에 있는 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(Variable Hoisting)이라 한다.

## 4.5. 값의 할당

변수 선언은 런타임 이전에 실행되지만, 값의 할당은 런타임에 실행된다.

```js
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당
console.log(score); // 80
```

변수에 값을 할당할 때는 undefined가 저장되어 있던 메모리에 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그곳에 할당 값을 저장한다.

### Example

```js
console.log(score); // undefined

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score); // 80
```

1. `var score;`이 호이스팅되어 코드 맨위로 올라간다 -> `undefined`로 초기화됨

2. `score = 80`으로 값을 할당하므로 80이 출력된다.

## 4.6. 값의 재할당

재할당은 변수에 저장된 값을 다른 값으로 변경한다. 변경할 수 없다면, 변수가 아니라 상수라 한다.

- `const` 키워드는 단 한 번만 할당할 수 있는 변수를 선언하므로, 재할당이 되지 않는다. 따라서, 상수를 사용할 떄 사용 가능하다.

값의 재할당 또한 새로운 메모리 공간에서 이루어지며, 변수의 이전 값은 가비지 콜렉터에 의해 자동으로 메모리에서 해제된다.

## 4.7. 식별자 네이밍 규칙

1. camelCase : 변수, 함수

2. PascalCase : 생성자함수, 클래스

<!-- # 5장. 표현식과 문 -->

<!-- # 6장. 데이터 타입 -->

<!-- # 7장. 연산자 -->

<!-- # 8장. 제어문 -->

<!-- # 9장. 타입 변환과 단축 평가 -->

<!-- # 10장. 객체 리터럴 -->

# 4장. 변수

### 4.4. 변수 선언의 실행 시점과 변수 호이스팅

- JS는 인터프리터 언어임.
- 변수 선언은 런타임(소스코드가 한 줄씩 순차적으로 실행되는 시점)이 아니라 그 이전 단계에서 먼저 실행됨.
- 이전 단계란 소스코드의 평가 과정을 의미하며, 이 과정에서 모든 선언문(변수, 함수 선언문 등..)을 찾아내 먼저 실행함.
- 이렇게 되면, 변수 선언이 소스코드의 어디에 위치하는지와 상관없이 어디서든지 변수를 참조 가능함.
- 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유 특징을 변수 호이스팅(hoisting)이라 함.
- 변수 외에도 모든 식별자는 호이스팅됨.

# 5장. 표현식과 문

### 5.2. 리터럴

- 리터럴은 사람이 이해할 수 있는 문자 또는 약속 기호를 사용해 값을 생성하는 표기법을 말함.
- ex.
  > 3 : 숫자 리터럴
  > 'hello' : 문자열 리터럴
  > true : 불리언 리터럴

### 5.6. 표현식인 문과 표현식이 아닌 문

- 이 둘을 구별할 수 있는 가장 간단명료한 방법은 변수에 할당해 보는 것.
- 변수 선언문은 변수에 할당할 수 없음 -> 표현식이 아닌 문!
```js
var foo = var x; //SyntaxError
```
- 할당문은 변수에 할당 가능 -> 표현식인 문!
```js
var foo = x = 100;
console.log(foo); //100
```

# 6. 데이터 타입

### 6.3. 템플릿 리터럴

- ES6부터 도입된 문자열 표기법임.
- 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능 제공.
- 백틱(``)사용하여 표현함.

#### 6.3.1. 멀티라인 문자열

- 템플릿 리터럴 내에서는 이스케이프 시퀀스를 사용하지 않아도 줄바꿈이 허용되며, 모든 공백도 적용됨.
```js
var template = `<ul>
    <li><a href = "#">Home</a></li>
<ul>`;

console.log(template);
/*
<ul>
    <li><a href = "#">Home</a></li>
<ul>
*/
```

#### 6.3.2. 표현식 삽입

- 템플릿 리터럴 내에서는 표현식을 ${}으로 감싸서 간단히 표현식을 삽입 가능함.
```js
var name = 'heebeom';
console.log(`My name is ${name}.`); //My name is heebeom.
```

### 6.5. undefined 타입

- 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이뤄질 때까지 JS 엔진이 undefined로 초기화함.
- 변수 참조시 undefined가 반환된다는 것은 변수 선언 후 초기화되지 않았다는 것임.
- 개발자가 의도적으로 undefined를 변수에 할당 가능하나 취지에 어긋남으로 권장하지 않음.
- 위 같이 변수에 값이 없다는 것을 의도적으로 명시하고 싶을 때 null을 사용함.

### 6.6. null 타입

- null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용.
- null 할당 -> 참조하던 값을 더 이상 참조X -> JS엔진이 해당 메모리 공간에 대해 가비지 컬렉션 수행.
- 함수가 유효한 값을 반환할 수 없을 때 명시적으로 null을 반환하기도 함.

### 6.7. 심벌 타입

- 변경 불가능한 원시 타입 값임.
- Symbol 함수를 호출해 생성함.
- 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값임.

### 6.9. 데이터 타입의 필요성

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 낭비없이 결정하기 위해.
- 값을 참조할 때 손실 없이 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해.
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정하기 위해.

### 6.10. 동적 타이핑

#### 6.10.1. 동적 타입 언어와 정적 타입 언어

- 정적타입 언어는 데이터 타입을 사전에 선언해야 함. (명시적 타입 선언)
- JS는 동적 타입 언어로 변수가 선언이 아닌 할당에 의해 타입이 결정됨. (타입 추론)
- 재할당에 의해 변수의 타입은 언제든 동적으로 변할 수 있음.(동적 타이핑)

#### 6.10.2. 동적 타입 언어와 변수

- 동적 타입 언어는 유연성은 높지만 신뢰성은 떨어짐.
- 따라서 변수 사용시 아래와 같은 주의 사항이 있음.
    1. 변수는 꼭 필요한 경우에 한해 제한적으로 사용.
    2. 변수의 유효범위(스코프)는 최대한 좁게 설정.
    3. 전역 변수는 최대한 사용하지 않기.
    4. 변수보다 상수 사용하기.
    5. 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍.

# 7. 연산자

### 7.1. 산술 연산자

#### 7.1.3. 문자열 연결 연산자

- +연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작함.
- 위 처럼 개발자의 의도와 상관없이 JS 엔진에 의해 암묵적으로 타입이 자동 변환되기도함.(암묵적 타입 변환, 타입 강제 변환)

### 7.3. 비교 연산자

#### 7.3.1. 동등/일치 비교 연산자

- 동등 비교 연산자(==)는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교함.
- 일치 비교 연산자(===)는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경에 한해 true를 반환함.
- NaN은 자신과 일치하지 않는 유일한 값임.
    ```js
    NaN === NaN; // false
    ```
- 양의 0과 음의 0을 비교하면 true를 반환함.
    ```js
    +0 === -0; // true.
    +0 == -0; // true.
    ```
- 위 두 경우는 Object.is() 메서드를 활용하여 예상 가능한 불린 값을 반환 받을 수 있음.

### 7.4. 삼항 조건 연산자

- if-else 문은 값처럼 사용 불가하나 삼함 조건 연산자는 가능함.

### 7.5. 논리 연산자

- 논리 부정(!) 연산자는 언제나 불리언 값을 반환함.
- 논리합(||), 논리곱(&&) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있으며, 언제나 2개의 피연산자 중 어느 한쪽으로 평가됨.

### 7.7. 그룹 연산자

- 그룹 연산자는 연산자 우선순위가 가장 높음.
- 그렇기 때문에 연산자 사용시 우선순위를 기억에 의존해 사용하기 보단 그룹 연산자(())를 사용하여 우선순위를 명시적으로 조절하는 것을 권장.

### 7.8. typeof 연산자

- "string", "number", "boolean", "undefined", "function", "symbol", "object" 중 하나를 반환함.
- null 값을 연산하면 "object"를 반환함. -> 수정되지 못하고 있는 오류임. -> === 를 활용해서 확인하자!
- 선언하지 않은 식별자를 연산하면 undefined가 반환됨.

# 8. 제어문

### 8.1. 블록문

### 8.2. 조건문

- if-else 문
- switch 문

### 8.3. 반복문

- for 문
- while 문
- do-while 문

### 8.4. break 문

### 8.5. continue 문

# 9. 타입 변환과 단축 평가

### 9.1. 타입 변환이란?

- 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 함.
- 개발자의 의도와 상관없이 표현식 평가 도중 JS 엔진에 의해 암묵적으로 타입이 자동 반환되는 것을 암묵적 타입 변환, 타입 강제 변환이라 함.
- 암문적 타입 변환은 기존 변수 값을 재할당하는 것이 아니라 새로운 타입의 값을 만들어 단 한 번 사용하고 버림.

### 9.2. 암묵적 타입 변환

#### 9.2.1. 문자열 타입으로 변환

- +연산자는 피연산자 중 하나 이상이 문자열이면 문자열 연결 연산자로 동작함.

#### 9.2.2. 숫자 타입으로 변환

- 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야 함.
- 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중 숫자 타입이 아닌 피연산자는 숫자 타입으로 암묵적 타입변환됨.
- +단한 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환됨.

#### 9.2.3. 불리언 타입으로 변환

- JS 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환함.
- JS 엔진은 불리언 값이 아닌 값을 Truthy 값 또는 Falsy 값으로 구분함.
- Falsy 값 : false, undefined, null, 0, -0, NaN, ''
- 위 외의 값은 전부 Truthy 값임.

### 9.3. 명시적 타입 변환

#### 9.3.1. 문자열 타입으로 변환

- String 생성자 함수를 new 연산자 없이 호출하는 방법.
- Object.prototype.toString 메서드를 사용하는 방법.
- 문자열 연결 연산자를 이용하는 방법.

#### 9.3.2. 숫자 타입으로 변환

- Number 생성자 함수를 new 연산자 없이 호출하는 방법.
- parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능).
- +단항 산술 연산자를 이용하는 방법.
- *산술 연산자를 이용하는 방법.

#### 9.3.3. 불리언 타입으로 변환

- Boolean 생성자 함수를 new 연산자 없이 호출하는 방법.
- ! 부정 논리 연산자를 두 번 사용하는 방법.

### 9.4. 단축 평가

#### 9.4.1. 논리연산자를 사용한 단축 평가

- 단축 평가란 논리연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환하는 것을 말함.
- 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략함.
- 사용 예시.
    - 객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 참조할 때.
    - 함수 매개변수에 기본값을 설정할 때.

#### 9.4.2. 옵셔널 체이닝 연산자

- 연산자 모양 : ?.
- 논리 연산자 &&는 좌항 피연산자가 Falsy 값이면 좌항 피연산자를 그대로 반환하는 반면,
- 옵셔널 체이닝 연산자 ?.는 좌항 피연산자가 Falsy 값이라도 null 또는 undefined가 아니면 우항의 프로퍼티 참조를 이어감.

#### 9.4.3. null 병합 연산자

- 연산자 모양 : ??
- 논리 연산자 ||의 경우 좌항의 피연산자가 Falsy 값이면 우항의 피연산자를 반환하는 반면,
- null 병합 연산자 ??는 좌항의 피연산자가 null 또는 undefined가 아니면 좌항의 피연산자를 그대로 반환함.

# 10. 객체 리터럴

### 10.1. 객체란?

- 원시 값을 제외한 나머지 모든 값.
- 다양한 타입의 값을 하나의 단위로 구성한 복합적인 자료구조.
- 객체는 변경 가능한 값임.
- JS에서 함수는 일급 객체이므로 값으로 취급할 수 있고 그렇기 때문에 프로퍼티 값으로 사용될 수 있음.
- 프로퍼티 값인 함수를 메서드라고 함.
- 프로퍼티 : 객체의 상태를 나타내는 값.
- 메서드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작.

### 10.2. 객체 리터럴에 의한 객체 생성

- JS는 프로토타입 기반 객체지향 언어임.
- 객체 생성 방법.
    1. 객체 리터럴.
    2. Object 생성자 함수.
    3. 생성자 함수.
    4. Object.create 메서드.
    5. 클래스(ES6)
- 객체 리터럴의 중괄호는 코드 블록을 의미하지 않음.
    ```js
    var person = {
        name : 'song',
        sayHello : function () {
            console.log(`Hello! My name is ${name}.`);
        }
    };
    ```
- 객체 리터럴 외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성함.

### 10.3. 프로퍼티

- 프로퍼티는 키와 값으로 구성.
- 나열할 때는 쉼표(,) 사용.
- 프로퍼티 키 : 빈 문자열을 포함한 모든 문자열 또는 심벌 값 사용 가능.
- 프로퍼티 값 : JS에서 사용가능한 모든 값 사용 가능.
- 프로퍼티 키는 반드시 식별자 네이밍 규칙을 따라야하는 것은 아님.
- 단, 그런 경우 키에 반드시 따옴표를 사용해야 함.
- 문자열 또는 문자열로 평가할 수 있는 표현식을 사용해 프로퍼티 키를 동적으로 생성할 경우 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야 함.
    ```js
    var obj = {};
    var key = 'hello';

    obj[key] = 'world';
    obj['fruit'] = 'apple';

    console.log(obj); //{ hello: 'world', fruit: 'apple' }
    ```
- 이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티가 먼저 선언한 프로퍼티를 덮어씀.

### 10.5. 프로퍼티 접근

- 마침표 표기법, 대괄호 표기법이 있음.
- 대괄호 프로퍼티 접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야 함.
- 객체에 존재하지 않는 프로퍼티에 접근하면 undefined 반환.
- 네이밍 규칙 준수 -> 마침표, 대괄호 표기법 모두 사용 가능.
- 네이밍 규칙 준수X -> 대괄호 표기법만 사용 가능. 단, 숫자로 이뤄진 문자열인 경우 따옴표 생략 가능.

### 10.6. 프로퍼티 값 갱신

- 이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신됨.

### 10.7. 프로퍼티 동적 생성

- 존재하지 않는 프로퍼티에 값 할당시 프로퍼티가 동적 생성됨.

### 10.8. 프로퍼티 삭제

- delete 연산자는 객체의 프로퍼티를 삭제함.
    ```js
    var person = {
        name : 'song',
        age : 26
    };

    delete person.age;
    delete person.address;

    console.log(person); //{name: "song"}
    ```

### 10.9. ES6에서 추가된 객체 리터럴의 확장 기능

#### 10.9.1. 프로퍼티 축약 표현

- 프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티 키를 생략할 수 있음.
    ```js
    let x = 1, y = 2;
    const obj = {x,y};

    console.log(obj); //{x: 1, y: 2}
    ```

#### 10.9.2. 계산된 프로퍼티 이름

#### 10.9.3. 메서드 축약 표현

```js
const obj = {
    name : "song",
    sayHi(){
        console.log('Hi!' + this.name);
    }
};

obj.sayHi(); // Hi! song
```
- 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작함.



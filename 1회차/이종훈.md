## 4장. 변수

### 4.1 변수란 무엇인가? 왜 필요한가?

애플리케이션은 기본적으로 데이터를 입력받아 처리하고 그 결과를 출력하는 것이 전부다. 이때 변수는 프로그래밍 언어에서 데이터를 관리하기 위한 핵심 개념이다.
- 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 
변수 이름을 사용해 참조를 요청하면 자바스크립트 엔진은 변수 이름과 매핑된 메모리 주소를 통해 메모리 공간에 접근해서 저장된 값을 반환한다. 

### 4.2 식별자

변수 이름을 식별자 라고도 한다.
- 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다. 
식별자는 값이 아니라 메모리 주소를 기억한다. 즉 식별자는 메모리 주소에 붙인 이름이라고도 할 수 있다. 

### 4.3 변수 선언

변수를 사용하려면 반드시 선언이 필요하다. 변수를 선언할 때는 var, let, const 키워드를 사용한다.
var 키워드는 여러 단점이 있다. 여러 단점 중 가장 대표적인 것이 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생하기도 한다. 이러한 단점을 보완하기 위해 나온 것이 const, let 키워드이다. 단 let과 const가 도입되었다고 해서 var 키워드가 폐기된 것은 아니다.

자바스크립트 엔진은 변수 선언을 1) 선언 단계, 2) 초기화 단계 2단계에 거쳐 수행한다.
1) 선언 단계 : 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2) 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.
var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행된다.

### 4.4 변수 선언의 실행 시점과 변수 호이스팅

- 변수 선언은 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행된다.
자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행된다. 
- 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라고 한다.
변수 선언뿐만 아니라 var, let, const. function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅된다.

### 4.5 값의 할당

변수를 선언한 후 값을 할당할 때는 할당 연산자 =를 사용한다. 할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

ex) 
```js
var score;
score = 80;
```

- 변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

### 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

ex)
```js
var score = 80;
score = 90;
```

- 값을 재할당할 수 없어서 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수라고 한다. 상수는 한번 정해지면 변하지 않는 값이다.

### 4.7 식별자 네이밍 규칙

식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.
1) 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(_), 달러 기호를 포함할 수 있다.
2) 단, 식별자는 특수문자를 제외한 문자, 언더스코어(_), 달러 기호로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
3) 예약어는 식별자로 사용할 수 없다. 예약어란 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 언어를 말한다. await, break, case 등이 포함된다.

---

## 5장. 표현식과 문

### 5.1 값

값은 표현식이 평가되어 생성된 결과를 말한다.
평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

### 5.2 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법을 말한다.
리터럴을 사용하면 다양한 종류의 값을 생성할 수 있다.

### 5.3 표현식

표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
값으로 평가될 수 있는 문은 모두 표현식이다.

### 5.4 문

문은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다.
문은 여러 토큰으로 구성된다. 토큰이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.

### 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 문의 종료를 나타낸다.
문의 끝에 붙이는 세미콜론은 자바스크립트에서는 옵션이다. 이는 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능이 암묵적으로 수행되기 때문이다.

### 5.6 표현식인 문과 표현식이 아닌 문

변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.
표현식인 문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다.

```js
var foo = var x;
```

---

## 6장. 데이터 타입

### 6.1 숫자 타입

C,Java의 경우 정수와 실수를 구분해서 int, long, float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.

### 6.2 문자열 타입

문자열 타입은 텍스트 데이터를 나타내는 데 사용한다. 문자열을 '', "", ``로 텍스트를 감싼다.

### 6.3 템플릿 리터럴

템플릿 리터럴은 멀티라인 문자열, 표현식 삽입, 태그드 템플릿 등 편리한 문자열 처리 기능을 제공한다. 

### 6.4 Boolean 타입

Boolean 타입은 true, false로 나타낸다.

### 6.5 undefined 타입

undefined 타입은 undefined가 유일하다. 이 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다.

### 6.6 null 타입

변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미이다. 이는 이전에 할당되어 있던 참조를 명시적으로 제거하는 것을 의미한다.

### 6.7 심벌 타입

심벌 타입은 변경 불가능한 원시 타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌한 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용된다.

### 6.8 객체 타입

자바스크립트의 데이터 타입은 크게 원시 타입과 객체 타입으로 나뉜다. 자세한 내용은 11장에서 다룬다.

### 6.9 데이터 타입의 필요성

1. 데이터 타입에 의한 메모리 공간의 확보와 참조
값은 메모리에 저장하고 참조할 수 있어야 한다. 이때 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다.
2. 데이터 타입에 의한 값의 해석

### 6.10 동적 타이핑

자바스크립트의 모든 값은 데이터 타입을 갖는다. 
C나 Java 같은 정적 타입 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언이라고 한다.
정적 타입 언어는 변수의 타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 이에는 C, C++, Java, Kotlin, Scala 등이 해당된다.
자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라고 한다.이에는 JavaScript, Python, PHP 등이 해당된다.
동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있어 편리하다. 하지만 편리함의 이면에는 위험도 도사리고 있다. 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 자동적으로 이상한 값으로 변화하기도 한다. 따라서 데이터 타입 체크를 주의해야 하고 가독성 좋은 코드를 작성해야 한다.

---

## 7장. 연산자

### 7.1 산술 연산자

1. 이항 산술 연산자
2개의 피연산자를 산술 연산하여 숫자 값을 만든다.
```js
5 + 2;
```

2. 단항 산술 연산자
1개의 피연산자를 산술 연산하여 숫자 값을 만든다.
```js
var x = 1;
x++;
```

3. 문자열 연결 연산자
+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.
```js
1 + '2'; // = 12
```

### 7.2 할당 연산자

할당 연산자는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.
```js
var x;
x = 10;
```

### 7.3 비교 연산자

비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 결과를 boolean 값으로 반환한다.

1. 동등/일치 비교 연산자
==, ===, !=, !==

2. 대소 관계 비교 연산자
>, <, >=, <=

### 7.4 삼항 조건 연산자

삼항 조건 연산자는 조건식의 평가 결과에 따라 반환할 값을 결정한다.
```js
var x = 2;
var result = x % 2 ? '홀수' : '짝수' ;
```
### 7.5 논리 연산자

논리 연산자는 우항과 좌항의 피연산자를 논리 연산한다.
||, &&, !

### 7.6 쉼표 연산자

, 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

### 7.7 그룹 연산자

그룹 연산자를 사용하면 연산자의 우선순위를 조절할 수 있다.
```js
10 * (2 + 3);
```

### 7.8 typeof 연산자

typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다.

### 7.9 지수 연산자

지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 값을 반환한다.

### 7.10 그 외의 연산자

?. : 옵셔널 체이닝 연산자
?? : null 병합 연산자
delete : 프로퍼티 삭제

### 7.11 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향을 주지 않지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과가 있다. 이에는 할당 연산자(=), 증가/감소 연산자(++, --), delete 연산자가 해당된다.

### 7.12 연산자 우선순위

연산자에는 우선순위가 있으며 우선순위가 높을수록 먼저 실행된다.
1. ()
2. new(매개변수 존재), [], (), ?
3. new(매개변수 미존재)
4. x++, x--
5. !x, +x, -x, ++x, --x, typeof, delete
6. **
7. *, /, %
8. +, -
9. <, <=, >, >=, in, instanceof
10. ==, !=, ===, !==
11. ??
12. &&
13. ||
14. ? ..., : ...
15. 할당 연산자
16. ,

### 7.13 연산자 결합 순서

연산자 결합 순서란 연산자의 어느 쪽부터 평가할 것인지를 나타내는 순서를 말한다.

---

## 8장. 제어문

### 8.1 블록문

블록문은 0개 이상의 문을 중괄호로 묶은 것으로, 코드 블록 또는 블록이라고 부르기도 한다.
```js
{
    var foo = 10;
}
```

### 8.2 조건문

조건문은 주어진 조건식의 평가 결과에 따라 코드 블록의 실행을 결정한다.

1. if ... else 문
if, else 구조로 사용한다.
2. switch 문
swith, case, break 구조로 사용한다.

### 8.3 반복문
반복문은 조건식의 평가 결과가 참인 경우 코드 블록을 실행한다.

1. for 문
2. while 문
3. do ... while 문

### 8.4 break 문

break문은 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록에서 사용되며 이외에 break 문을 사용하면 SyntaxError가 발생한다.

### 8.5 continue 문

continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 실행 흐름을 이동시킨다. 


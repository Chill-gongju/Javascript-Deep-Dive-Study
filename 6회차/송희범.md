# 31. RegExp (정규표현식)

## 31.1. 정규 표현식이란?

정규 표현식은 일정한 패턴을 가진 문자열의 집합을 표현하기 위해 사용하는 형식 언어임.

특정 패턴과 일치하는 문자열을 검색하거나 추출 또는 치환할 수 있는 기능인 패턴 매칭 기능을 제공함.

### 정규 표현식 장단점.
- 장점: 반복문, 조건문 없이 패턴을 정의하고 테스트하는 것으로 간단히 체크 가능.
- 단점: 가독성이 떨어짐.

## 31.2. 정규 표현식의 생성

```js
/regexp/i // 정규 표현식 리터럴
// \/ -> 시작·종료 기호, i -> 플래그, regexp -> 패턴

const regexp = new RegExp(/is/i); //RegExp 생성자 함수

//생성자 함수를 사용하면 동적으로 객체 생성 가능.

const count = (str, char) => (str.match(new RegExp(char, 'gi'))??[]).length;

count('Is this all there is?', 'is'); // 3
```

## 31.3. RegExp 메서드

### 31.3.1. RegExp.prototype.exec

정규 표현식의 패턴을 검색하여 매칭 결과를 배열로 반환함.

매칭 결과 없으면 null 반홤!

g(전체 검색) 플래그를 사용해도 첫 번째 매칭 결과만 반환함.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.exec(target); // ["is", index: 5, ...]
```

### 31.3.2. RegExp.prototype.test

정규 표현식의 패턴을 검색하여 매칭 결과를 불리언 값으로 반환함.

```js
const target = 'Is this all there is?';
const regExp = /is/;

regExp.test(target); // true
```

### 31.3.3. String.prototype.match

매칭 결과를 배열로 반환함.

g 플래그가 지정되면 모든 매칭 결과를 배열로 반환함.

```js
const target = 'Is this all there is?';
const regExp = /is/g;

target.match(regExp); // ["is", "is"]
```

## 31.4. 플래그

정규 표현식의 검색 방식을 설정하기 위해 사용하고 총 6 종류가 있음.

3가지 주요 플래그

| 플래그 |  의미     |  설명                   |
|-------|-----------|-------------------------|
|i      |Ignore case|대소문자 구별없이 패턴 검색|
|g      |Global     |모든 문자열을 전역 검색    |
|m      |Multi line |행이 바뀌어도 계속 패턴 검색|

플래그는 옵션임. 순서 상관없이 하나 이사의 플래그를 동시 사용 가능.

플래그 없으면 대소문자 구별해서 첫 번째 매칭 대상만 패턴을 검색하고 종료함.

## 31.5. 패턴

패턴은 문자열의 일정한 규칙을 표현하기 위해 사용함.

패턴은 /로 열고 닫으며 문자열의 따옴표는 생략함.

특별한 의미를 가지는 메타문자 또는 기호로 표현 가능함.

### 31.5.1. 문자열 검색

정규 표현식을 생성한 후 RegExp 메서드를 사용하여 검색 대상 문자열과 정규 표현식의 매칭을 구하면 검색이 수행됨.

### 31.5.2. 임의의 문자열 검색

.은 임의의 문자 한 개를 의미함.

### 31.5.3. 반복 검색

{m,n}은 앞선 패턴이 최소 m번, 최대 n번 반복되는 문자열을 의미함.

{n}은 {n,n}과 같음.

{n,}은 앞선 패턴이 최소 n번 이상 반복되는 문자열을 의미함.

+는 {1,}과 같음 -> 앞선 패턴이 최소 한번 이상 반복되는 문자열을 의미함.

?는 {0,1}과 같음 -> 앞선 패턴이 최대 한 번(0번 포함) 이상 반복되는 문자열을 의미함.

```js
const target = 'color colour colouur';
const regExp = /colou?r/g;

console.log(target.match(regExp)); //[ 'color', 'colour' ]
```

### 31.5.4. OR 검색

|은 or을 의미함.

[] 내의 문자는 or로 동작함.

범위를 지정하려면 []내에 -를 사용함.

\d는 숫자를 의미함.

\D는 숫자가 아닌 문자를 의미함.

\w는 알파벳, 숫자, 언더스코어를 의미함.

\W는 알파벳, 숫자, 언더스코어가 아닌 문자를 의미함.

### 31.5.5. NOT 검색

[]내의 ^는 nor을 의미함 -> \D는 [^0-9]와 같음.

### 31.5.6. 시작 위치로 검색

[]밖의 ^는 문자열의 시작을 의미함.

### 31.5.7. 마지막 위치로 검색

\$는 문자열의 마지막을 의미함.

## 31.6. 자주 사용하는 정규표현식

### 31.6.1. 특정 단어로 시작하는지 검사

```js
const url = "https://example.com";

/^https?:\/\//.test(url); //true
```

### 31.6.2. 특정 단어로 끝나는지 검사

```js
const fileName = 'index.html';

/html$/.test(fileName); // true
```

### 31.6.3. 숫자로만 이루어진 문자열인지 검사

```js
const target = '12354';

/^\d+$/.test(target); // true
```

### 31.6.4. 하나 이상의 공백으로 시작하는지 검사

\s는 여러 가지 공백 문자(탭, 스페이스 등)를 의미함.

```js
const target = '  Hi';

/^[\s]+/.test(target); //true
```

### 31.6.5. 아이디로 사용 가능한지 검사

```js
const id = 'abc123';

// 알파벳 대소문자 또는 숫자로 이루어진 4-10자리 아이디
/^[A-Za-z0-9]{4,10}$/.test(id) //true
```

### 31.6.6. 메일 주소 현식에 맞는지 검사

() : ()안 문자를 하나의 문자로 취급

\* : 앞 문자를 0번 이상 반복

```js
const email = 'heebeom@mail.com';

/^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/.test(email); //true
```

### 31.6.7. 핸드폰 번호 형식 

```js
const cellphone = "010-1111-2222";

/^\d{3}-\d{3,4}-\d{4}$/.test(cellphone); //  true
```

### 31.6.8. 특수 문자 포함 여부 검사

```js
const target = 'adsf#$%123`;

(/[^A-Za-z0-9]/gi).test(target);//true

//특수문자 제거
target.replace(/[^A-Za-z0-9]/gi, ''); //adsf123
```

# 32. String

## 32.1. String 생성자 함수

new 연산자와 함께 인수에 아무것도 전달 하지 않고 호출하면 [[StringData]] 내부 슬롯에 빈 문자열을 할당한 String 래퍼 객체 생성.

인수로 문자열 전달하면 해당 문자열을 할당한 String 래퍼 객체 생성

문자열이 아닌 것을 인수로 전달하면 문자열로 강제 변환 후 변환된 문자열을 할당한 String 래퍼 객체 생성

new 연산자 없이 String 생성자 함수 호출하면 String 인스턴스가 아닌 문자열을 반환 -> 명시적 타입 변환.

## 32.2. length 프로퍼티

문자 개수를 변환함.

String 래퍼 객체는 유사 배열 객체로 배열과 마찬가지로 length 프로퍼티를 갖음.

## 32.3. String 메서드

String 객체의 메서드는 언제나 새로운 문자열을 반환.

즉 문자열은 변경 불가능한 원시 값이기 때문에 String 래퍼 객체도 읽기 전용 객체로 제공됨.

### 32.3.1. String.prototype.indexOf

index 메서드는 인수로 전달 받은 문자열을 검색하여 첫 번째 인덱스를 반환함. 검색 실패시 -1 반환.

2번째 인수로 검색 시작 인덱스 지정 가능.

```js
str.indexOf('l', 3);
```

### 32.3.2. String.prototype.search

인수로 전달받은 정규 표현식과 매치하는 문자열을 검색하여 일치하는 문자열의 인덱스 반환. 검색 실패시 -1.

```js
str.search(/o/ig);
```

### 32.3.3. String.prototype.includes

인수로 전달받은 문자열이 포함되어 있는지 확인 후 불리언 값 리턴.

2번째 인수로 검색 시작 인덱스 지정 가능.

```js
str.includes('hi', 3);
```

### 32.3.4. String.prototype.startWith

인수로 받은 문자열로 시작하는지 확인 후 불리언값 리턴.

2번째 인수로 검색 시작 인덱스 지정 가능.

```js
str.startsWith(' ', 5);
```

### 32.3.5. String.prototype.endsWith

인수로 받은 문자열로 끝나는지 확인 후 불리언 값 리턴.

2번째 인수로 검색할 문자열 길이 지정 가능.

```js
str.endsWith('lo', 3);
```

### 32.3.6. String.prototype.charAt

인수로 받은 인덱스에 위치한 문자를 검색하여 리턴.

인덱스가 문자열의 범위를 벗어난 경우 빈 문자열 리턴.

```js
str.charAt(5);
```

### 32.3.7. String.prototype.substring

1번째 인수로 받은 인덱스에 위치하는 문자부터 2번째 인수로 받은 인덱스에 위치한 문자 바로 이전 문자까지 부분 문자열 리턴.

2번째 인수 생략 가능 -> 마지막 문자까지 부분 문자열 리턴

1번째 인수 > 2번째 인수 -> 두 인수는 교환됨.

인수 < 0 또는 NaN -> 인수 0으로 취급.

인수 > 문자열길이 -> 인수는 문자열 길이로 취급.

```js
const str = 'Hello World';

str.substring(1,4); // ell
```

cf. indexOf 메서드와 함께 사용하면 특정 문자열 기준 앞뒤에 위치한 부분 문자열 취득 가능.

### 32.3.8. String.prototype.slice

substring 메서드와 동일하게 동작함. 단 음수인 인수를 받을 수 있음. -> 문자열 뒤에서 부터 시작.

```js
const str = 'hello world';

str.slice(-5); // world
```

### 32.3.9. String.prototype.toUpperCase

모두 대문자로 변경한 문자열을 리턴.

### 32.3.10. String.prototype.toLowerCase

모두 소문자로 변경한 문자열을 리턴.

### 32.3.11. String.prototype.trim

앞뒤 공백 문자가 있을 경우 이를 제거한 문자열 반환.

trimStart -> 앞 공백만 제거

trimEnd -> 뒤 공백만 제거

### 32.3.12. String.prototype.repeat

인수로 전달받은 정수만큼 반복해 연결한 새 문자열 리턴.

인수가 0이면 빈 문자열 리턴.

음수이면 RangeError 발생.

생략하면 기본 값 0으로 설정.

### 32.3.13. String.prototype.replace

1번째 인수로 전달받은 문자열 또는 정규표현식을 검색하여 2번째 인수로 전달한 문자열로 치환한 문자열 리턴.

검색된 문자열 다수 존재시 첫 번째 검색 문자열만 치환.

특수한 교체 패턴 사용 가능 (ex. $& -> 검색된 문자열을 의미).

2번째 인수로 치환 함수를 전달할 수 있음.

### 32.3.14. String.prototype.split

1번째 인수로 전달된 문자열 또는 정규 표현식을 검색하여 문자열로 구분한 후 분리된 각 문자열로 이루어진 배열을 리턴함.

인수로 빈 문자열 전달시 각 문자를 모두 분리하고, 인수를 생략하면 대상 문자열 전체를 단일 요소로 하는 배열 리턴함.

2번째 인수로 리턴될 배열의 길이를 지정할 수 있음.

```js
const str = 'How are you?';

str.split(' ', 2); // ['How', 'are']
```

# 35. 스프레드 문법

스프레드 문법(...)은 하나로 뭉쳐져 있는 여러 값들을 펼쳐서 개별적인 **값들의 목록**으로 만듦.  
for-of 문으로 순회할 수 있는 **이터러블**에 한정되어 사용 가능함.  
스프레드 문법의 결과는 값이 아니고 ...은 연산자가 아니기 때문에 스프레드 문법 결과를 변수에 할당할 수 없음.  

다음과 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용 가능함.

- 함수 호출문의 인수 목록
- 배열 리터럴의 요소 목록
- 객체 리터럴의 프로퍼티 목록

## 35.1. 함수 호출문의 인수 목록에서 사용하는 경우

```js
const arr = [1,2,3];

const max = Math.max(...arr); //3
```

cf. 스프레드 문법과 Rest 파라미터  
두 문법의 형태가 닮아서 혼동할 수 있으나!  
Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 ...을 붙이는것이고  
스프레드 문법은 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것임.  
즉 서로 반대 개념임.

## 35.2. 배열 리터럴 내부에서 사용하는 경우

### 35.2.1. concat

배열을 결합하고 싶을 때 ES6이전에는 concat 메서드를 사용하였으나 ES6이후 스프레드 문법으로 간소화 할 수 있음.

```js
const arr = [...[1,2], ...[3,4]];

console.log(arr);//[1,2,3,4]
```

### 35.2.2. splice

ES6 이전 배열 중간에 배열 요소를 추가 또는 제거 하려면 splice 메서드와 apply 메서드를 조합하여 사용해야 중간에 배열이 아닌 배열의 요소를 추가 할 수 있었음.  
그러나 ES6 이후 스프레드 문법을 사용하면 아래와 같이 간략하게 표현가능함!

```js
const arr1 = [1,4];
const arr2 = [2,3];

arr1.splice(1,0,...arr2); // [1,2,3,4]
```

### 35.2.3. 배열 복사

ES6 이전에는 배열의 얕은 복사(중첩객체는 참조값 공유로 복사됨)를 원할 시 slice 메서드에 아무런 인수도 전달하지 않는 형태로 구현하였으나  
스프레드 문법을 사용하면 아래와 같이 간결하게 구현 가능함.

```js
const origin = [1,2];
const copy = [...origin]; // [1,2]
```

### 35.2.4. 이터러블을 배열로 변환

ES6 이전 이터러블을 배열로 변환하려면 apply 또는 call 메서드와 slice 메서드를 조합해서 사용해야 했음.  
이 방법은 이터러블이 아닌 유사배열객체도 배열로 변환 가능함.  
ES6 이후에는 스프레드 문법으로 간단하게 변환 가능하나 이 방법은 유사배열객체는 변환 불가함.  

```js
function sum(){
    return [...arguments].reduce((pre, cur)=>pre+cur, 0);
}

sum(1,2,3); // 6

//Rest 파라미터로 더욱 더 간소화 가능
const sum = (...args) => args.reduce((pre, cur)=>pre+cur, 0);

sum(1,2,3);//6
```

유사 배열 객체를 배열로 간편하게 변환 하려면 Array.from 메서드를 사용하면 됨.

```js
const arrayLike = {
    0: 1,
    1: 2,
    2: 3,
    length: 3
};

Array.from(arrayLike); //[1,2,3]
```

## 35.3. 객체 리터럴 내부에서 사용하는 경우

스프레드 프로퍼티 제안은 이터러블이 아닌 일반 객체를 대상으로도 스프레드 문법의 사용을 허용함!!

```js
const obj = {x:1, y:2};
const copy = {...obj}; //{x:1, y:2}

const merged = {x:1, y:2, ...{a:3, b:4}}; // {x:1, y:2, a:3, b:4}
```

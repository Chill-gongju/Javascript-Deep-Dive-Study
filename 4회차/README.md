# 21장 빌트인 객체

- 자바스크립트의 객체는 어떤 종류로 분류되나요?
    - 이소: 표준 빌트인 객체, 호스트 객체, 사용자 정의 객체
- 문자열이나 숫자, 불리언 등의 원시값이 있는데도 문자열, 숫자, 불리언 객체를 생성하는 string, number, boolean 등의 표준 빌트인 생성자 함수가 존재하는 이유는?
    - 채온: 자바스크립트는 원시값에 메서드를 직접 사용할 수 없음 → 래퍼 객체로 감싸서 사용
- 래퍼 객체란 무엇이며 어떻게 동작하나요?
    - 종훈리: 원시값을 객체처럼 사용하기 위해, 자바스크립트 엔진이 암묵적으로 생성
- 전역 객체(Global Object)란 무엇이고, 어떤 프로퍼티들을 가지고 있나요?
    - 히범: 어떤 객체보다도 가장 먼저 생성되는 특수한 객체 / 브라우저 → window, Node.js → global
    - 프로퍼티는 isFinity, NaN, undefined 3가지
- window.infinite, NaN, undefined 같은 전역 프로퍼티는 언제 사용되나요?
    - 이소: infinity는 무한대를 나타내는 숫자를 검사 / NaN은 숫자인지 확인하기 위해 / undefined는 ??? 값이 할당됐는지 확인
- eval 함수의 동작 원리와 사용을 지양해야 하는 이유는 무엇인가요?
    - 채온: 보안 문제, 최적화 문제가 있고 디버깅이 어렵기 때문에 사용을 지양해야 함

# 22장 this

- 자바스크립트에서 this는 어떤 개념이며, 어떻게 결정되나요?
    - 종훈리: 자기 참조 변수 / 함수 호출 방식에 의해 값이 동적으로 결정됨
- this 바인딩이 동적으로 결정된다는 것은 무슨 의미인가요?
    - 히범: 말그대로! 함수의 호출 방식에 따라 this가 바인딩 되는 것이 유동적으로 결정된다는 뜻입니다.
- this가 바인딩되는 방식 4가지는 무엇인가요?
    - 이소: 일반 함수 호출 - 전역 객체 / 메서드 - 메서드를 호출한 객체 / 생성자 함수 - 이 함수로 생성되는 인스턴스 / Function.prototype.apply, call, bind 메서드 - 첫번째 인수로 전달한 객체
- call, apply, bind의 차이점은 무엇인가요?
    - 채온: call, apply는 둘 다 함수 호출 기능인데 call은 쉼표로 구분한 뒤 인수로 전달하고  apply는 배열로 묶어서 전달하고 bind는 메서드의 this와 메서드 내부의 중첩 함수 또는 콜백 함수가 불일치하는 문제를 해결하기 위해서 사용합니다.

# 23장 실행 컨텍스트

- 실행 컨텍스트란 무엇이며, 자바스크립트에서 왜 중요한가요?
    - 종훈리: 자바스크립트 엔진에서 동작 원리를 담고 있는 객체, 중요한 이유는 코드 순서를 관리하기 위해서..
- 자바스크립트 소스코드는 평가와 실행 단계로 나뉘는데, 각각 무엇을 의미하나요?
    - 히범: 흠.. 평가단계에서는  실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 생성된 변수나 함수 식별자를 키로 실행 컨텍스트가 관리하는 스코프에 등록함.
        
        실행단계에서는 선언문을 제외한 소스코드가 순차적으로 실행됨.(런타임)
        
        실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 검색하여 취득함.
        
        변수 값의 변경 등 소스코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록됨.
        
- 실행 컨텍스트 스택은 어떤 역할을 하나요?
    - 이소: 스코프랑 코드의 실행 순서를 관리하는 역할을 합니다. 아 음 스택은 코드의 실행 순서를 관리하는데 스택의 가장 위에 있는 실행 컨텍스트는 현재 실행 중인 코드의 실행 컨텍스트입니다……………………………………………
- 렉시컬 환경(Lexical Environment)이란 무엇이며, 어떤 구성 요소를 가지고 있나요?
    - 채온: 식별자와 스코프를 관리하는 공간 / 환경 레코드, 외부 렉시컬 환경에 대한 참조
- var, let, const 선언 시 실행 컨텍스트에 어떤 차이가 생기나요?
    - 종훈리: var : 함수레벨스코프 →  / let, const: 블록레벨스코프, 함수 레벨 스코프는 함수의 코드 블록만 지역 스코프로 인정하고 블록레벨 스코프는 모든 코드 블록을 지역 스코프로 인정한다
    - 히범: 렉시컬 환경은 환경 레코드와 외부 렉시컬 환경에 대한 참조로 나뉘는데 이때 환경 레코드는 객체 환경 레코드, 선언적 환경 레코드로 구성됨. var 변수는 객체 환경 레코드에서 관리되고 let const는 선언적 환경 레코드에서 관리됨.
- 전역 코드와 함수 코드 실행 시 컨텍스트 생성 흐름을 설명해주세요.
    - 이소: 전역 코드는 먼저 식별자인지 확인을 하고 변수 할당문(전역 객체 생성)이 실행됩니다. / 함수 코드는 함수 실행 컨텍스트를 먼저 만들고, 함수 렉시컬 환경을 만듭니다.
    
    > "전역 코드는 전역 실행 컨텍스트가 먼저 만들어지고, 함수 코드는 호출 시 함수 실행 컨텍스트가 별도로 만들어집니다. 이때 함수는 자신이 정의된 위치의 스코프를 기억하고 실행되며, 각각 고유한 렉시컬 환경을 가지게 됩니다."
    > 
    - 전역 코드: 코드 실행 시 / 상위 스코프는 null
    - 함수 코드: 함수 호출 시 / 상위 스코프는 함수 정의된 위치에 따라 결정됨
- 실행 컨텍스트의 생성과 식별자 검색 과정은 어떻게 이루어지나요?
    - 채온: 실행 컨텍스트 생성은 생성 단계, 실행 단계로 나뉘어짐
        - 생성 단계: 변수, 함수 선언을 환경 레코드에 저장 / 실행 단계: 변수 값 할당 및 코드 실행
        - 식별자 검색 과정: 현재 실행 컨텍스트에서 검색하고, 없으면 상위 스코프로 이동하면서 검색 / 전역 컨텍스트까지 가도 없으면 ReferenceError 발생

# 24장 클로저

- 클로저란 무엇인가요?
    - 종훈리: 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있는 내부 중첩 함수
- 클로저가 생성되는 조건은 무엇인가요?
    - 히범: 중첩 함수가 전역 변수에 참조되어 있고 중첩 함수 내부에서 외부 함수의 변수를 참조하고 있다면 외부 함수의 실행 컨텍스트가 실행 컨텍스트에서 제거되어도 외부 함수의 렉시컬 환경은 중첩 함수의 [[Environment]]에 의해 참조되고 있고 중첩 함수는 전역 변수에 의해 참조되고 있기 때문에 가비지 컬렉터는 해당 메모리 공간을 해제 하지 않음.
- 렉시컬 스코프와 클로저의 관계는 어떻게 되나요?
    - 이소: 렉시컬 스코프는 함수가 어디서 정의했는지에 따라 상위 스코프가 결정되는 것인데 이 렉시컬 스코프에 따라 클로저가 결정됩니다. 즉 참조 관계를 의미
- 클로저의 내부 작동 원리를 설명해보세요.
    - 채온: 함수가 선언될 때 함수의 렉시컬 환경도 함께 저장되는데 클로저가 참조 중인 변수는 가비지 컬렉션이 가져가지 않도록 남겨둔다.
    
    [면접관 앞에서 클로저 (closure)의 동작원리를 말해보자](https://velog.io/@minh0518/%EB%A9%B4%EC%A0%91%EA%B4%80-%EC%95%9E%EC%97%90%EC%84%9C-%ED%81%B4%EB%A1%9C%EC%A0%80-closure%EC%9D%98-%EB%8F%99%EC%9E%91%EC%9B%90%EB%A6%AC%EB%A5%BC-%EB%A7%90%ED%95%B4%EB%B3%B4%EC%9E%90)
    
- 클로저를 사용할 때 자주 발생하는 실수에 대한 해결 방법은 무엇인가요?
    - 종훈리: for문 안에서 let으로 변수 선언하고, 고차 함수 사용해라

# 25장 클래스

- 클래스는 프로토타입 기반 문법의 문법적 설탕(멍청한 개발자를 위해 문법을 좀 더 쉽게 바꿔 준거임?)인가요? 질문이 슈가? 예스 플리즈!
    - 히범: 새로운 객체 생성 매커니즘이라고 보는 것이 타당합니다~ 네에~
- ES6의 클래스와 ES5의 생성자 함수 방식의 차이점은 무엇인가요?
    - 이소: 클래스는 1. new 연산자 없으면 에러가 생기고 2. 상속을 지원합니다 3. 호이스팅이 발생하지 않는것처럼 동작하고 4. 암묵적으로 strict mode 가 있습니다 5. 클래스의 constructor, 프로토타입 메서드, 정적메서드는 [[Enumerable]] 값이 false라고 하네요
- 클래스도 호이스팅이 되나요?
    - 채온: 클래스는 호이스팅이 발생하지 않는 것처럼 보이지만 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생
- 클래스에서 사용할 수 있는 메서드의 종류와 차이점을 설명해주세요.
    - 종훈리: constructor, 프로토타입 메서드, 정적메서드
    
    **정적 메서드와 프로토타입 메서드의 차이**
    
    1. 자신이 속해있는 프로토타입 체인이 다르다.
    2. 정적 메서드는 클래스로 호출하고, 프로토타입 메서드는 인스턴스로 호출한다.
    3. 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, 프로토타입 메서드는 가능하다.
- 클래스의 인스턴스 생성 과정을 순서대로 설명해주세요.
    - 히범
        1. 인스턴스를 생성하고 this에 바인딩 합니다.
        2. 인스턴스를 초기화 합니다.
        3. 인스턴스가 바인딩된 this가 반환됩니다.
- extends와 super 키워드는 어떤 역할을 하나요?
    - 이소: extends는 상속할 때 사용되고 super는 부모를 호출할 때 사용합니다.
- 클래스를 상속받을 때 super 호출 순서와 규칙은 어떻게 되나요?
    - 채온: super를 먼저 호출해야 하고 다음에 생성자에서 this를 사용하기 전에 호출해야 하고 부모 메서드를 오버라이딩할 때는 super.methodName()으로 접근, super()에 인수를 전달하면 부모 생성자에 인수 전달
- 클래스 없이도 객체지향을 구현할 수 있는 이유는 무엇인가요?
    - 종훈리: ES5에서 클래스 없이도 “생성자 함수와 프로토타입을 통해” 객체지향 언어의 상속을 구현할 수 있습니다.
    - 히범: 애초에 자바스크립트가 프로토타입 기반 언어이기 때문에 클래스 따위는 없어도 생성자 함수와 프로토타입을 통해서 객체지향을 구현할 수 있다!
    
    > 자바스크립트는 **클래스 기반 언어가 아닌 프로토타입 기반 언어**입니다.
    즉, **객체를 복제하거나 확장하는 방식**으로 상속과 캡슐화 등 객체지향 프로그래밍(OOP)의 핵심 개념을 구현할 수 있습니다.
    ES5 이전에는 클래스 문법이 없었지만, 다음 두 가지 개념을 통해 객체지향을 구현할 수 있었습니다.
    > 
    
    1️⃣ **생성자 함수 (Constructor Function)**
    
    2️⃣ **프로토타입 (Prototype)**
    

🤜🏻 🤛🏻

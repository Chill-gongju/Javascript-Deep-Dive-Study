# 21. 빌트인 객체

## 21.1. 자바스크립트 객체의 분류

JS 객체는 크게 3가지로 분류됨.

- 표준 빌트인 객체 : 애플리케이션 전역의 공통 기능을 제공함.
- 호스트 객체 : JS 실행 환경에서 추가로 제공하는 객체.
- 사용자 정의 객체 : 사용자가 직접 정의한 객체.

## 21.2. 표준 빌트인 객체

40여개의 표준 빌트인 객체가 있으며 Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 생성자 함수 객체임.

생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고 그렇지 않은 객체는 정적 메서드만을 제공함.

## 21.3. 원시값과 래퍼 객체

원시 값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없는데도 원시 값이 객체처럼 동작할 때가 있음.

이는 원시 값인 문자열, 숫자, 불리언 값의 경우 이들 원시 값에 대해 마치 객체처럼 마침표 표기법으로 접근하면 JS 엔진이 일시적으로 원시 값을 연관된 임시 객체로 변환해 주기 때문이며 이를 래퍼 객체라 함.

작동 방법은...

1. 원시 값에 마침표 표기법으로 접근.
2. 래퍼 객체가 생성되며 해당 원시 값이 래퍼 객체의 [[원시값Data]] 내부 슬롯에 할당.
3. 이때 생성된 래퍼객체는 원시값.prototype의 메서드를 상속받음.
4. 래퍼 객체 처리 종료.
5. 래퍼 객체의 [[원시값Data]] 내부 슬롯에 할당되어 있던 원시 값이 원래 상태로 돌아감.
6. 래퍼 객체는 가비지 컬렉션의 대상이 됨.

이렇듯 문자열, 숫자, 불리언, 심볼은 암묵적으로 생성되는 래퍼 객체에 의해 객체 처럼 사용 가능함으로 생성자 함수로 인스턴스를 생성할 필요가 없음.(권장X)

참고로 null과 undefined는 래퍼 객체를 생성하지 않음!

## 21.4. 전역 객체

코드 실행 전 JS 엔진에 의해 최우선으로 생성되는 특수 객체이며, 어떤 객체에도 속하지 않는 최상위 객체임.

환경에 따라 지칭하는 이름이 다름. ex. 브라우저 : window, self, this... / Node.js : global

> cf. globalThis
>
> ES11에서 도입된 전역 객체를 가리키던 다양한 식별자를 통일한 식별자임.

전역 객체의 특징은...

- 전역 객체를 생성할 수 있는 생성자 함수는 제공되지 않음.
- 전역 객체의 프로퍼티를 참조할 때 window(or global)를 생략 가능함.
- 모든 표준 빌트인 객체를 프로퍼티로 갖고 있음.
- 실행 환경에 따라 추가적으로 프로퍼티와 메서드를 갖음.
    - 브라우저 환경 : 클라이언트 사이드 Web API
    - Node.js 환경 : Node.js 고유의 API
- var 키워드로 선언한 전역 변수와 암묵적 전역, 전역 함수는 전역 객체의 프로퍼티가 됨.
- let, const 전역 변수는 전역 객체 프로퍼티가 아님.
- 브라우저 환경의 모두 JS 코드는 하나의 전역 객체 window를 공유함.

### 21.4.1. 빌트인 전역 프로퍼티

전역 객체의 프로퍼티를 의미함.

- Infinity : 무한대를 나타내는 숫자값.
- NaN : 숫자가 아님을 나타내는 숫자값.
- undefined

### 21.4.2. 빌트인 전역 함수

애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메서드.

- eval : 기존의 스코프를 동적으로 수정함. but 보안에 취약하고 JS 엔진에 의해 최적화 X -> 사용 금지!
- isFinite : 정상적인 유한수인지 검사함.
- isNaN : NaN인지 검사함.
- parseFloat : 실수로 해석하여 반환함.
- parseInt : 정수로 해석하여 반환함. 두 번째 인수로 진법을 나타내는 기수를 전달할 수 있음.
    - 10진수 숫자를 해당 기수의 문자열로 변환하여 반환 받고 싶을 때는 Number.prototype.toString 사용.
- encodeURI : 완전한 URI를 문자열로 받아 이스케이프 처리를 위해 인코딩함.
- decodeURI : 인코딩된 URI를 인수로 전달받아 이스케이프 처리 이전으로 디코딩함.
- encodeURIComponent : URI 구성요소를 인수로 받아 인코딩함.
- decodeURIComponent : 전달받은 URI 구성요소를 디코딩함.
    - encodeURIComponent는 전달된 문자열을 쿼리 스트링 일부로 간주하여 쿼리 스트링 구분자도 인코딩함.
    - encodeURI는 전달된 문자열을 완전한 URI 전체라고 간주하여 쿼리 스트링 구분자는 인코딩되지 않음.

### 21.4.3. 암묵적 전역

선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문에 마치 전역 변수처럼 동작함.

그러나 이는 변수가 아니므로 변수 호이스팅이 일어나진 않음.

변수가 아닌 프로퍼티인 암묵적 전역 변수는 delete 연산자로 삭제 가능한 전역 변수는 프로퍼티지만 delete 연산자로 삭제할 수 없음.

# 22. this

## 22.1. this 키워드

this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수임.

this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있음.

this는 JS 엔진에 의해 암묵적으로 생성됨.

코드 어디서든 참조 가능함.

this 바인딩은 함수 호출 방식에 의해 동적으로 결정됨.

객체 리터럴의 메서드 내부에서의 this는 메서드를 호출한 객체임.

생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킴.

전역에서 this는 전역 객체 window를 가리킴.

strict mode가 적용된 일반 함수 내부의  this에는 undefined가 바인딩됨. -> 일반 함수 내부에서 this는 전역 객체 window를 가리키기 때문에 쓸모가 없음!

## 22.2. 함수 호출 방식과 this 바인딩

### 22.2.1. 일반 함수 호출

전역 함수는 물론이고 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩됨.

이는 외부 함수인 메서드와 중첩 함수 또는 콜백 함수의 this가 일치하지 않는다는 것을 뜻하고 이렇게 되면 중첩 함수 또는 콜백 함수를 헬퍼 함수로 동작하기 어렵게 만듦.

이를 해결하기 위해 아래 3가지 방법이 주로 쓰임.

1. this 바인딩을 변수(that 등)에 할당함.

```js
const obj = {
    value: 100,
    foo() {
        const that = this;

        setTimeout(function(){
            console.log(that.value);
        }, 100);
    }
};
```

2. Function.prototype.bind() 메서드 사용.

```js
const obj = {
    value: 100,
    foo() {
        setTimeout(function(){
            console.log(this.value);
        }.bind(this), 100);
    }
};
```

3. 화살표 함수 사용 (화살표 함수의 함수 내부 this는 상위 스코프의 this를 가리킴.)

```js
const obj = {
    value: 100,
    foo() {
        setTimeout(()=> console.log(this.value), 100);
    }
};
```

### 22.2.2. 메서드 호출

메서드 내부의 this에는 메서드를 호출한 객체가 바인딩됨.

프로토타입 메서드 내부에서 사용된 this도 일반 메서드와 마찬가지로 해당 메서드를 호출한 객체에 바인딩됨.

### 22.2.3. 생성자 함수 호출

생성자 함수 내부의 this에는 생성자 함수가 생성할 인스턴스 바인딩됨.

### 22.2.4. Function.prototype.apply/call/bind 메서드에 의한 간접 호출

Function.prototype의 메서드들임.

apply와 call 메서드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 this로 사용할 객체를 전달하면서 함수를 호출하는 것은 동일함.

apply와 call 메서드의 대표적인 용도는 유사 배열 객체와 같은 배열이 아닌 객체가 Array.prototype.slice 같은 배열 메서드를 사용할 수 있게 해줌.

```js
const arr = Array.prototype.slice.call(arguments);
```

bind 메서드는 첫 번째 인수로 전달한 값으로 this 바인딩이 교체된 함수를 새롭게 생성하여 반환함.

```js
const person = {
    name: 'Lee',
    foo(callback){
        setTimeout(callback.bind(this), 100);
    }
};
```

함수 호출 방식에 따른 this 동적 바인딩은 아래와 같음!

|함수 호출 방식|this 바인딩|
|-------------|----------|
|일반 함수 호출|전역 객체|
|메서드 호출|메서드를 호출한 객체|
|생성자 함수 호출|생성자 함수가 생성할 인스턴스|
|Function.prototype.apply/call/bind 메서드에 의한 간접 호출|Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체|

# 23. 실행 컨텍스트


# 36장. 디스트럭처링 할당

디스트럭처링 할당 = 구조 분해 할당

이터러블 or 객체를 디스트럭처링하여 1개 이상의 변수에 개별적으로 할당하는 것

### 배열

> 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당

- 할당의 대상은 이터러블
- 할당 기준은 배열의 인덱스
- 할당의 변수 개수와 이터러블의 요소 개수가 반드시 일치하지 않아도 된다.
- 할당을 위해 변수에 기본값을 설정할 수 있다.

### 객체

> 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변ㅅ에 할당

- 할당의 대상은 객체
- 프로퍼티 키로 필요한 프로퍼티 값만 추출하여 변수에 할당하고 싶을 때 유용하게 사용
- 할당을 위해 변수에 기본값을 설정할 수 있다.

<br/>
<br/>

# 37장. Set과 Map

## Set

중복되지 않는 유일한 값들의 집합

#### Set 객체 생성

Set 생성자 함수로 생성

#### `Set.prototype.size`

- 요소 개수를 확인할 때 사용

#### `Set.prototype.add`

- 요소를 추가할 때 사용

#### `Set.prototype.has`

- 특정 요소가 존재하는지 확인할 때 사용

#### `Set.prototype.delete`

- 특정 요소를 삭제할 때 사용

#### `Set.prototype.clear`

- 모든 요소를 일괄 삭제할 때 사용

#### `Set.prototype.forEach`

- 순회할 때 사용
- 첫 번째 인수 → 현재 순회 중인 요소 값
- 두 번째 인수 → 현재 순회 중인 요소 값
- 세 번째 인수 → 현재 순회 중인 Set 객체 자신

## Map

Map 객체는 키와 값의 쌍으로 이뤄진 컬렉션

객체와 유사하지만 다음과 같은 차이점이 존재한다.

- 키로 사용할 수 있는 값: 객체를 포함한 모든 값
- 이터러블: O
- 요소 개수 확인: Map.prototype.size

#### Map 객체 생성

Map 생성자 함수로 생성

#### `Map.prototype.size`

- 요소 개수를 확인할 때 사용

#### `Map.prototype.set`

- 요소를 추가할 때 사용

#### `Map.prototype.get`

#### `Map.prototype.has`

- 특정 요소가 존재하는지 확인할 때 사용

#### `Map.prototype.delete`

- 특정 요소를 삭제할 때 사용

#### `Map.prototype.clear`

- 특정 요소를 삭제할 때 사용

#### `Map.prototype.forEach`

- 순회할 때 사용
- 첫 번째 인수 → 현재 순회 중인 요소 값
- 두 번째 인수 → 현재 순회 중인 요소 키
- 세 번째 인수 → 현재 순회 중인 Map 객체 자신

<br/>
<br/>

# 38장. 브라우저의 렌더링 과정

### 브라우저가 렌더링을 하는 과정

1. 브라우저는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다.

2. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다.

3. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행한다. 이때 자바스크립트는 DOM API를 통해 CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 렌더 트리로 변경된다.

4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산하고 브라우저 화면에 HTML 요소를 페인팅한다.

### HTML 파싱과 DOM 생성

문자열로 이루어진 텍스트 문서를 브라우저에 렌더링하려면, 문서를 브라우저가 이해할 수 있는 자료구조로 변환하여 메모리에 저장해야 한다.

DOM은 HTML문서를 파싱한 결과물이다.

### CSS 파싱과 CSSOM 생성

link 태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청하여 로드한 CSS 파일이나 style 태그 내 CSS를 HTML과 동일한 파싱 과정을 거치며 해석하여 CSSOM을 생성한다.

### 렌더 트리 생성

렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM을 생성한다. DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다.

### 자바스크립트 파싱과 실행

자바스크립트 코드에서 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작할 수 있다.

1. 자바스크립트 파일 역시 HTML의 DOM 생성을 일시 중단시킨다.
2. 그리고 자바스크립트 코드 파싱은 자바스크립트 엔진에게 제어권이 넘어간다.
3. 파싱 종료 후 렌더링 엔진으로 다시 제어권이 넘어간다.

### 리플로우와 리페인트

DOM API가 사용된 경우 DOM이나 CSSOM이 변경된다.

- 리플로우: 레이아웃 계산을 다시 하는 것
- 리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트 하는 것

<br/>
<br/>

# 39장. DOM

브라우저 렌더링 엔진은 HTML문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 DOM을 생성한다.

> DOM은 HTML 문서의 게층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조다.

### 노드

트리 자료구조는 노드들의 계층 구조로 이뤄진다.

트리 자료구조는 부모 노드와 자식 노드로 구성되어 노드 간 계층적 구조를 표현하는 비선형 자료구조를 말한다.

트리 자료구조는 하나의 최상위 노드에서 시작한다.

최상위 노드는 부모 노드가 없으며, 루트 노드라 한다. 루트 노드는 0개 이상의 자식 노드를 갖는다. 자식 노드가 없는 노드를 리프 노드라 한다.

- 문서 노드
  - DOM 트리의 최상위에 존재하는 루트 노드로서 document 객체를 가리킨다.
- 요소 노드
  - HTML 요소를 가리키는 객체다.
  - 문서의 구조를 표현함
- 어트리뷰트 노드
  - HTML 요소의 어트리뷰트를 가리키는 객체다.
  - 부모 노드가 없고 어트리뷰트가 지정된 요소 노드와 연결되어 있음
- 텍스트 노드
  - HTML 요소의 텍스트를 가리키는 객체다.
  - 문서의 정보를 표현함
  - 요소 노드의 자식 노드이며, 자식 노드를 가질 수 없는 리프 노드

### 요소 노드 취득

HTML의 구조가 내용 또는 스타일 등을 동적으로 조작하는 요소 노드를 취득해야 한다.

DOM은 요소 노드를 취득할 수 있는 다양한 메서드를 제공한다.

- id를 이용한 요소 노드 취득
- 태그 이름 이용
- class 이용
- CSS 선택자 이용
- Element.prototye.matches 메서드
  - 특정 요소 노드를 취득할 수 있는지 확인
- HTMLCollection과 NodeList
  - DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체

### 노드 탐색

요소 노드를 취득한 다음, 취득한 요소 노드를 기점으로 DOM 트리의 노드를 옮겨 다니며 부모, 형제, 자식 노드 등을 탐색해야 할 때가 있다.

노드 탐색 프로퍼티는 모두 접근자 프로퍼티다. 단, setter 없이 getter만 존재하여 참조한 가능한 읽기 전용 접근자 프로퍼티다.

### 노드 정보 취득

#### `Node.prototype.nodeType`

- 노드 객체의 종류, 노드 타입을 나타내는 상수를 반환

#### `Node.prototype.nodeName`

- 노드의 이름을 문자열로 반환

### DOM 조작

DOM 조작이란, 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드를 삭제 또는 교체하는 것이다.

DOM 조작에 의해 DOM에 새로운 노드가 추가되거나 삭제되면 리플로우와 리페인트가 발생하는 원인이 되므로 성능에 영향을 준다.

#### `innerHTML`

#### `insertAdjacentHTML`

#### `노드 생성과 추가`

### 어트리뷰트

HTML 문서의 구성 요소인 HTML 요소는 여러 개의 어트리뷰트를 가질 수 있다. HTML 요소의 동작을 제허가 위한 추가적인 정보를 제공하는 HTML 어트리뷰트는 HTML 요소의 시작 태그에 어트리뷰트 이름을 정의한다.

<br/>
<br/>

# 40장. 이벤트

### 이벤트 드리븐 프로그래밍

브라우저는 처리해야 할 특정 사건이 발생하면 이를 감지하여 이벤트를 발생시킨다. 예를 들어 클릭, 키보드 입력, 마우스 이동이 있다.

애플리케이션이 특정 타입의 이벤트에 대해 반응하여 어떤 일을 하고 싶다면 해당하는 타입의 이벤트가 발생했을 때 호출될 함수를 브라우저에 알려 호출을 위임한다.

- 이벤트 헨들러 : 이벤트가 발생했을 때 호출될 함수
- 이벤트 헨들러 등록 : 이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것

### 이벤트 타입

이벤트 타입은 이벤트의 종류를 나타내는 문자열이다. 약 200여가지가 있다.

### 이벤트 핸들러 등록

이벤트 핸들러는 이벤트가 발생하면 브라우저에 의해 호출될 함수다.

이벤트 핸들러를 등록하는 방법은 3가지다.

1. 이벤트 헨들러 어트리뷰트 방식

2. 이벤트 헨들러 프로퍼티 방식

3. addEventListner 방식

### 이벤트 객체

이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다.

생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.

### 이벤트 전파

DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파라고 한다.

### 이벤트 위임

이벤트 위임을 통해 하위 DOM 요소에서 발생한 이벤트를 처리할 때 주의할 점은 상위 요소에 이벤트 핸들러를 등록하기 때문에 이벤트 타깃, 즉 이벤트를 실제로 발생시킨 DOM 요소가 개발자가 기대한 DOM 요소가 아닐 수도 있다는 것이다.

따라서 이벤트에 반응이 필요한 DOM 요소에 한정하여 이벤트 핸들러가 실행되도록 이벤트 타깃을 검사할 필요가 있다.

### DOM 요소의 기본 동작의 조작

DOM 요소는 저마다 기본 동작이 있다.

- 이벤트 객체의 `preventDefault` 메서드는 이러한 DOM 요소의 기본 동작을 중단시킨다.
- 이벤트 객체의 `stopPropagation` 메서드는 이벤트 전파를 중지시킨다.

### 이벤트 핸들러 내부의 this

handleClick 함수 내부의 this는 전역 객체 window를 가리킨다.

### 커스텀 이벤트

이벤트 객체는 Event, UIEvent, MouseEvent 등과 같은 이벤트 생성자 함수로 생성할 수 있다.

이벤트 생성자 함수는 첫 번째 인수로 이벤트 타입을 나타내는 문자열을 전달받는다.
이때 이벤트 타입을 나타내는 문자열은 기존 이벤트 타입을 사용할 수 있고, 임의의 문자열을 사용할 수도 있다.
